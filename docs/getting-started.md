# Getting Started with Relay

Relay is a high-performance, source-generator powered mediator and messaging framework for .NET. It provides compile-time code generation to eliminate runtime reflection overhead, enabling efficient request/response patterns, command handling, and event publishing with minimal performance impact.

## Installation

Install the Relay NuGet package:

```bash
dotnet add package Relay
```

Or install the individual packages:

```bash
# Core runtime components
dotnet add package Relay.Core

# Source generator (automatically included with main package)
dotnet add package Relay.SourceGenerator
```

## Quick Start

### 1. Define Your Requests and Handlers

```csharp
using Relay.Core;

// Define a request
public record GetUserQuery(int UserId) : IRequest<User>;

// Define a handler using attributes
public class UserService
{
    [Handle]
    public async ValueTask<User> GetUser(GetUserQuery query, CancellationToken cancellationToken)
    {
        // Your handler logic here
        return new User { Id = query.UserId, Name = "Murat Genc" };
    }
}

public record User
{
    public int Id { get; init; }
    public string Name { get; init; } = string.Empty;
}
```

### 2. Configure Dependency Injection

```csharp
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

var builder = Host.CreateApplicationBuilder(args);

// Register Relay services (generated by source generator)
builder.Services.AddRelay();

// Register your services
builder.Services.AddScoped<UserService>();

var host = builder.Build();
```

### 3. Use the Mediator

```csharp
using Microsoft.Extensions.DependencyInjection;

// Get the relay instance
var relay = host.Services.GetRequiredService<IRelay>();

// Send a request
var user = await relay.SendAsync(new GetUserQuery(123));
Console.WriteLine($"User: {user.Name}");
```

## Core Concepts

### Requests and Responses

Relay supports three types of operations:

1. **Request/Response**: Commands and queries that return a single result
2. **Requests**: Commands that don't return a value
3. **Streaming**: Requests that return `IAsyncEnumerable<T>` for large datasets
4. **Notifications**: Events that can have multiple handlers

```csharp
// Request with response
public record GetOrderQuery(int OrderId) : IRequest<Order>;

// Request without response (command)
public record CreateOrderCommand(string CustomerName) : IRequest;

// Streaming request
public record GetOrderHistoryQuery(int CustomerId) : IStreamRequest<Order>;

// Notification (event)
public record OrderCreatedNotification(int OrderId) : INotification;
```

### Handler Attributes

Use attributes to register handlers without boilerplate:

```csharp
public class OrderService
{
    // Basic handler
    [Handle]
    public async ValueTask<Order> GetOrder(GetOrderQuery query, CancellationToken cancellationToken)
    {
        // Implementation
    }

    // Named handler for multiple strategies
    [Handle(Name = "Premium")]
    public async ValueTask<Order> GetPremiumOrder(GetOrderQuery query, CancellationToken cancellationToken)
    {
        // Premium implementation
    }

    // Command handler (no return value)
    [Handle]
    public async ValueTask CreateOrder(CreateOrderCommand command, CancellationToken cancellationToken)
    {
        // Implementation
    }

    // Streaming handler
    [Handle]
    public async IAsyncEnumerable<Order> GetOrderHistory(
        GetOrderHistoryQuery query, 
        [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        // Yield results
        yield return new Order();
    }

    // Notification handler
    [Notification]
    public async ValueTask OnOrderCreated(OrderCreatedNotification notification, CancellationToken cancellationToken)
    {
        // Handle event
    }
}
```

### Pipeline Behaviors

Add cross-cutting concerns with pipeline behaviors:

```csharp
public class LoggingPipeline
{
    private readonly ILogger<LoggingPipeline> _logger;

    public LoggingPipeline(ILogger<LoggingPipeline> logger)
    {
        _logger = logger;
    }

    [Pipeline(Order = 1)]
    public async ValueTask<TResponse> LogRequests<TRequest, TResponse>(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        _logger.LogInformation("Handling {RequestType}", typeof(TRequest).Name);
        
        var stopwatch = Stopwatch.StartNew();
        try
        {
            var response = await next();
            _logger.LogInformation("Completed {RequestType} in {ElapsedMs}ms", 
                typeof(TRequest).Name, stopwatch.ElapsedMilliseconds);
            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed {RequestType} after {ElapsedMs}ms", 
                typeof(TRequest).Name, stopwatch.ElapsedMilliseconds);
            throw;
        }
    }
}
```

## Advanced Features

### Named Handlers

Use named handlers for different strategies:

```csharp
// Send to specific handler
var premiumOrder = await relay.SendAsync(new GetOrderQuery(123), "Premium");
```

### Notifications with Multiple Handlers

```csharp
public class EmailService
{
    [Notification(Priority = 1)]
    public async ValueTask SendWelcomeEmail(OrderCreatedNotification notification, CancellationToken cancellationToken)
    {
        // Send email
    }
}

public class InventoryService
{
    [Notification(Priority = 2)]
    public async ValueTask UpdateInventory(OrderCreatedNotification notification, CancellationToken cancellationToken)
    {
        // Update inventory
    }
}

// Publish to all handlers
await relay.PublishAsync(new OrderCreatedNotification(orderId));
```

### Streaming with Backpressure

```csharp
[Handle]
public async IAsyncEnumerable<LogEntry> GetLogs(
    GetLogsQuery query,
    [EnumeratorCancellation] CancellationToken cancellationToken)
{
    await foreach (var log in _logRepository.StreamLogsAsync(query.StartDate, cancellationToken))
    {
        yield return log;
        
        // Built-in backpressure handling
        if (cancellationToken.IsCancellationRequested)
            yield break;
    }
}

// Consume stream
await foreach (var log in relay.StreamAsync(new GetLogsQuery(DateTime.Today)))
{
    Console.WriteLine(log.Message);
}
```

## Performance Benefits

Relay provides significant performance improvements over reflection-based mediators:

- **Zero Runtime Reflection**: All handler discovery and registration happens at compile-time
- **Direct Method Calls**: Generated code calls handlers directly without reflection
- **Minimal Allocations**: Optimized for low memory allocation
- **ValueTask Support**: Efficient async operations with ValueTask
- **Object Pooling**: Built-in pooling for frequently used objects

## Configuration

### Global Configuration

```csharp
builder.Services.Configure<RelayOptions>(options =>
{
    options.DefaultTimeout = TimeSpan.FromSeconds(30);
    options.EnableTelemetry = true;
    options.NotificationDispatchMode = NotificationDispatchMode.Parallel;
});
```

### Attribute-Level Configuration

```csharp
[Handle(Priority = 10)]
[Notification(DispatchMode = NotificationDispatchMode.Sequential, Priority = 5)]
[Pipeline(Order = 100, Scope = PipelineScope.Requests)]
```

## Next Steps

- [API Documentation](api-documentation.md)
- [Performance Guide](performance-guide.md)
- [Migration Guide](migration-guide.md)
- [Developer Experience Features](developer-experience.md) - Diagnostics, testing, and compile-time validation
- [Diagnostics Guide](diagnostics-guide.md) - Comprehensive monitoring and debugging
- [Testing Guide](testing-guide.md) - Advanced testing utilities and patterns
- [Examples](examples/)

## Troubleshooting

### Common Issues

1. **Handler Not Found**: Ensure your handler class is registered in DI and the method has the correct attribute
2. **Compilation Errors**: Check that your request/response types implement the correct interfaces
3. **Performance Issues**: Review your pipeline order and consider using ValueTask for synchronous operations

### Enable Diagnostics

```csharp
builder.Services.Configure<RelayOptions>(options =>
{
    options.EnableDiagnostics = true;
    options.LogLevel = LogLevel.Debug;
});
```

For more detailed troubleshooting, see the [Troubleshooting Guide](troubleshooting.md).