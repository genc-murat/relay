using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Relay.SourceGenerator
{
    /// <summary>
    /// Generates DI container registration code for handlers.
    /// </summary>
    public class DIRegistrationGenerator
    {
        private readonly RelayCompilationContext _context;

        public DIRegistrationGenerator(RelayCompilationContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
        }

        /// <summary>
        /// Generates the DI registration extension methods.
        /// </summary>
        public string GenerateDIRegistrations(HandlerDiscoveryResult discoveryResult)
        {
            var sourceBuilder = new StringBuilder();

            // File header
            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("// Generated by Relay.SourceGenerator");
            sourceBuilder.AppendLine($"// Generation time: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
            sourceBuilder.AppendLine();

            // Usings
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sourceBuilder.AppendLine("using Microsoft.Extensions.DependencyInjection.Extensions;");
            sourceBuilder.AppendLine("using Relay.Core;");
            sourceBuilder.AppendLine("using Relay.Generated;");
            sourceBuilder.AppendLine();

            // Namespace
            sourceBuilder.AppendLine("namespace Microsoft.Extensions.DependencyInjection");
            sourceBuilder.AppendLine("{");

            // Generate extension class
            GenerateServiceCollectionExtensions(sourceBuilder, discoveryResult);

            sourceBuilder.AppendLine("}");

            return sourceBuilder.ToString();
        }

        private void GenerateServiceCollectionExtensions(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
        {
            sourceBuilder.AppendLine("    /// <summary>");
            sourceBuilder.AppendLine("    /// Extension methods for registering Relay handlers with the DI container.");
            sourceBuilder.AppendLine("    /// </summary>");
            sourceBuilder.AppendLine("    public static class RelayServiceCollectionExtensions");
            sourceBuilder.AppendLine("    {");

            // Generate main AddRelay method
            GenerateAddRelayMethod(sourceBuilder, discoveryResult);

            // Generate individual handler registration methods
            GenerateHandlerRegistrationMethods(sourceBuilder, discoveryResult);

            sourceBuilder.AppendLine("    }");
        }

        private void GenerateAddRelayMethod(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
        {
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Registers all Relay handlers and services with the DI container.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        /// <param name=\"services\">The service collection.</param>");
            sourceBuilder.AppendLine("        /// <returns>The service collection for chaining.</returns>");
            sourceBuilder.AppendLine("        public static IServiceCollection AddRelay(this IServiceCollection services)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            // Register core Relay services");
            sourceBuilder.AppendLine("            services.TryAddSingleton<IRelay, RelayImplementation>();");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            // Register endpoint metadata");
            sourceBuilder.AppendLine("            Relay.Generated.GeneratedEndpointMetadata.RegisterEndpoints();");

            // Register notification dispatcher if we have notification handlers
            var hasNotificationHandlers = discoveryResult.Handlers
                .Any(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Notification));

            if (hasNotificationHandlers)
            {
                sourceBuilder.AppendLine("            services.TryAddSingleton<INotificationDispatcher, Relay.Generated.GeneratedNotificationDispatcher>();");
            }

            sourceBuilder.AppendLine();

            // Register all handler types
            var handlerTypes = discoveryResult.Handlers
                .Where(h => !h.MethodSymbol.IsStatic)
                .Select(h => h.MethodSymbol.ContainingType.ToDisplayString())
                .Distinct()
                .ToList();

            if (handlerTypes.Any())
            {
                sourceBuilder.AppendLine("            // Register handler types");
                foreach (var handlerType in handlerTypes)
                {
                    var lifetime = GetHandlerLifetime(handlerType, discoveryResult);
                    sourceBuilder.AppendLine($"            services.Add{lifetime}<{handlerType}>();");
                }
                sourceBuilder.AppendLine();
            }

            sourceBuilder.AppendLine("            return services;");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
        }

        private void GenerateHandlerRegistrationMethods(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
        {
            // Group handlers by type for individual registration methods
            var handlersByType = discoveryResult.Handlers
                .Where(h => !h.MethodSymbol.IsStatic)
                .GroupBy(h => h.MethodSymbol.ContainingType.ToDisplayString())
                .ToList();

            foreach (var group in handlersByType)
            {
                var handlerType = group.Key;
                var handlers = group.ToList();

                GenerateIndividualHandlerRegistration(sourceBuilder, handlerType, handlers);
            }
        }

        private void GenerateIndividualHandlerRegistration(StringBuilder sourceBuilder, string handlerType, List<HandlerInfo> handlers)
        {
            var typeName = handlerType.Split('.').Last();
            var lifetime = GetHandlerLifetime(handlerType, null);

            sourceBuilder.AppendLine($"        /// <summary>");
            sourceBuilder.AppendLine($"        /// Registers {typeName} with the specified lifetime.");
            sourceBuilder.AppendLine($"        /// </summary>");
            sourceBuilder.AppendLine($"        /// <param name=\"services\">The service collection.</param>");
            sourceBuilder.AppendLine($"        /// <returns>The service collection for chaining.</returns>");
            sourceBuilder.AppendLine($"        public static IServiceCollection Add{lifetime}<T>(this IServiceCollection services) where T : class");
            sourceBuilder.AppendLine("        {");

            switch (lifetime)
            {
                case "Singleton":
                    sourceBuilder.AppendLine("            services.TryAddSingleton<T>();");
                    break;
                case "Scoped":
                    sourceBuilder.AppendLine("            services.TryAddScoped<T>();");
                    break;
                case "Transient":
                default:
                    sourceBuilder.AppendLine("            services.TryAddTransient<T>();");
                    break;
            }

            sourceBuilder.AppendLine("            return services;");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
        }

        private string GetHandlerLifetime(string handlerType, HandlerDiscoveryResult? discoveryResult)
        {
            // For now, default to Scoped for handlers
            // This could be enhanced to read from attributes or configuration
            return "Scoped";
        }
    }
}