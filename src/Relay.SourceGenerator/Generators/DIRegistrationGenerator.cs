using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Relay.SourceGenerator
{
    /// <summary>
    /// Generates DI container registration code for handlers.
    /// </summary>
    public class DIRegistrationGenerator
    {
        private readonly RelayCompilationContext _context;

        public DIRegistrationGenerator(RelayCompilationContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
        }

        /// <summary>
        /// Generates the DI registration extension methods.
        /// </summary>
        public string GenerateDIRegistrations(HandlerDiscoveryResult discoveryResult)
        {
            var sourceBuilder = new StringBuilder();

            // File header
            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("// Generated by Relay.SourceGenerator");
            sourceBuilder.AppendLine($"// Generation time: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
            sourceBuilder.AppendLine();

            // Usings
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine("using Microsoft.AspNetCore.Builder;");
            sourceBuilder.AppendLine("using Microsoft.AspNetCore.Hosting;");
            sourceBuilder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sourceBuilder.AppendLine("using Microsoft.Extensions.DependencyInjection.Extensions;");
            sourceBuilder.AppendLine("using Relay.Core;");
            sourceBuilder.AppendLine("using Relay.Core.Contracts.Core;");
            sourceBuilder.AppendLine("using Relay.Core.Contracts.Dispatchers;");
            sourceBuilder.AppendLine("using Relay.Generated;");
            sourceBuilder.AppendLine();

            // Namespace
            sourceBuilder.AppendLine("namespace Microsoft.Extensions.DependencyInjection");
            sourceBuilder.AppendLine("{");

            // Generate extension class
            GenerateServiceCollectionExtensions(sourceBuilder, discoveryResult);

            sourceBuilder.AppendLine("}");

            return sourceBuilder.ToString();
        }

        private void GenerateServiceCollectionExtensions(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
        {
            sourceBuilder.AppendLine("    /// <summary>");
            sourceBuilder.AppendLine("    /// Extension methods for registering Relay handlers with the DI container.");
            sourceBuilder.AppendLine("    /// </summary>");
            sourceBuilder.AppendLine("    public static class RelayServiceCollectionExtensions");
            sourceBuilder.AppendLine("    {");

            // Generate main AddRelay method
            GenerateAddRelayMethod(sourceBuilder, discoveryResult);

            // Generate individual handler registration methods
            GenerateHandlerRegistrationMethods(sourceBuilder, discoveryResult);

            sourceBuilder.AppendLine("    }");
        }

        private void GenerateAddRelayMethod(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
        {
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Registers all Relay handlers and services with the DI container.");
            sourceBuilder.AppendLine("        /// Enhanced with performance optimizations.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        /// <param name=\"services\">The service collection.</param>");
            sourceBuilder.AppendLine("        /// <returns>The service collection for chaining.</returns>");
            sourceBuilder.AppendLine("        public static IServiceCollection AddRelay(this IServiceCollection services)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            // Register core Relay services");
            sourceBuilder.AppendLine("            services.TryAddSingleton<IRelay, RelayImplementation>();");
            sourceBuilder.AppendLine();

            // Register fallback dispatchers (optimized versions would be generated separately)
            sourceBuilder.AppendLine("            // Register request and stream dispatchers");
            sourceBuilder.AppendLine("            services.TryAddTransient<IRequestDispatcher, FallbackRequestDispatcher>();");
            sourceBuilder.AppendLine("            services.TryAddTransient<IStreamDispatcher, StreamDispatcher>();");

            // Register notification dispatcher if we have notification handlers
            var hasNotificationHandlers = discoveryResult.Handlers
                .Any(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Notification));

            if (hasNotificationHandlers)
            {
                sourceBuilder.AppendLine("            services.TryAddSingleton<INotificationDispatcher, GeneratedNotificationDispatcher>();");
            }

            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            // Register endpoint metadata");
            sourceBuilder.AppendLine("            GeneratedEndpointMetadata.RegisterEndpoints();");
            sourceBuilder.AppendLine();

            // Register all handler types
            var handlerTypes = discoveryResult.Handlers
                .Where(h => !h.MethodSymbol.IsStatic)
                .Select(h => h.MethodSymbol.ContainingType.ToDisplayString())
                .Distinct()
                .ToList();

            if (handlerTypes.Any())
            {
                sourceBuilder.AppendLine("            // Register handler types");
                foreach (var handlerType in handlerTypes)
                {
                    var lifetime = GetHandlerLifetime(handlerType, discoveryResult);
                    sourceBuilder.AppendLine($"            services.Add{lifetime}<{handlerType}>();");
                }
                sourceBuilder.AppendLine();
            }

            // Pre-warm handler cache for better startup performance
            sourceBuilder.AppendLine("            // Pre-warm handler cache for optimal performance");
            sourceBuilder.AppendLine("            services.AddSingleton<IStartupFilter, RelayWarmupFilter>();");
            sourceBuilder.AppendLine();

            sourceBuilder.AppendLine("            return services;");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            // Generate warmup filter
            GenerateWarmupFilter(sourceBuilder, handlerTypes);
        }

        private void GenerateHandlerRegistrationMethods(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
        {
            // Group handlers by type for individual registration methods
            var handlersByType = discoveryResult.Handlers
                .Where(h => !h.MethodSymbol.IsStatic)
                .GroupBy(h => h.MethodSymbol.ContainingType.ToDisplayString())
                .ToList();

            foreach (var group in handlersByType)
            {
                var handlerType = group.Key;
                var handlers = group.ToList();

                GenerateIndividualHandlerRegistration(sourceBuilder, handlerType, handlers);
            }
        }

        private void GenerateIndividualHandlerRegistration(StringBuilder sourceBuilder, string handlerType, List<HandlerInfo> handlers)
        {
            var typeName = handlerType.Split('.').Last();
            var lifetime = GetHandlerLifetime(handlerType, null);

            sourceBuilder.AppendLine($"        /// <summary>");
            sourceBuilder.AppendLine($"        /// Registers {typeName} with the specified lifetime.");
            sourceBuilder.AppendLine($"        /// </summary>");
            sourceBuilder.AppendLine($"        /// <param name=\"services\">The service collection.</param>");
            sourceBuilder.AppendLine($"        /// <returns>The service collection for chaining.</returns>");
            sourceBuilder.AppendLine($"        public static IServiceCollection Add{lifetime}<T>(this IServiceCollection services) where T : class");
            sourceBuilder.AppendLine("        {");

            switch (lifetime)
            {
                case "Singleton":
                    sourceBuilder.AppendLine("            services.TryAddSingleton<T>();");
                    break;
                case "Scoped":
                    sourceBuilder.AppendLine("            services.TryAddScoped<T>();");
                    break;
                case "Transient":
                default:
                    sourceBuilder.AppendLine("            services.TryAddTransient<T>();");
                    break;
            }

            sourceBuilder.AppendLine("            return services;");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
        }

        private void GenerateWarmupFilter(StringBuilder sourceBuilder, List<string> handlerTypes)
        {
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Startup filter to pre-warm handler cache for optimal performance");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        private sealed class RelayWarmupFilter : IStartupFilter");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            public Action<IApplicationBuilder> Configure(Action<IApplicationBuilder> next)");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                return app =>");
            sourceBuilder.AppendLine("                {");
            sourceBuilder.AppendLine("                    // Pre-warm handler cache");
            sourceBuilder.AppendLine("                    var serviceProvider = app.ApplicationServices;");

            foreach (var handlerType in handlerTypes)
            {
                sourceBuilder.AppendLine($"                    {_context.AssemblyName}.Generated.RelayPerformanceCache.WarmUpHandler<{handlerType}>(serviceProvider);");
            }

            sourceBuilder.AppendLine("                    next(app);");
            sourceBuilder.AppendLine("                };");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
        }

        private string GetHandlerLifetime(string handlerType, HandlerDiscoveryResult? discoveryResult)
        {
            // Enhanced lifetime detection based on handler characteristics

            // Check if handler is stateless and can be singleton
            if (IsStatelessHandler(handlerType, discoveryResult))
            {
                return "Singleton";
            }

            // Check if handler needs per-request scope
            if (IsRequestScopedHandler(handlerType, discoveryResult))
            {
                return "Scoped";
            }

            // Default to scoped for most handlers
            return "Scoped";
        }

        private bool IsStatelessHandler(string handlerType, HandlerDiscoveryResult? discoveryResult)
        {
            // Simple heuristic - handlers ending with "Query" are often stateless
            // In a real implementation, this would analyze the handler class
            return handlerType.Contains("Query") || handlerType.Contains("Reader");
        }

        private bool IsRequestScopedHandler(string handlerType, HandlerDiscoveryResult? discoveryResult)
        {
            // Handlers that need request scope (e.g., those using Entity Framework)
            return handlerType.Contains("Command") || handlerType.Contains("Writer");
        }
    }
}