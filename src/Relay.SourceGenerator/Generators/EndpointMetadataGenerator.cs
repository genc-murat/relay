using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Relay.SourceGenerator.Generators;

namespace Relay.SourceGenerator
{
    /// <summary>
    /// Generates endpoint metadata registration code for handlers marked with ExposeAsEndpoint attribute.
    /// Implements the Strategy pattern via ICodeGenerator interface.
    /// </summary>
    public class EndpointMetadataGenerator : BaseCodeGenerator
    {
        private readonly Compilation _compilation;
        private readonly IDiagnosticReporter _diagnosticReporter;

        public EndpointMetadataGenerator(Compilation compilation, IDiagnosticReporter diagnosticReporter)
        {
            _compilation = compilation;
            _diagnosticReporter = diagnosticReporter;
        }

        /// <inheritdoc/>
        public override string GeneratorName => "Endpoint Metadata Generator";

        /// <inheritdoc/>
        public override string OutputFileName => "GeneratedEndpointMetadata";

        /// <inheritdoc/>
        public override int Priority => 60; // Run last

        /// <inheritdoc/>
        public override bool CanGenerate(HandlerDiscoveryResult result)
        {
            // Only generate if there are handlers with ExposeAsEndpoint attribute
            return result != null && result.Handlers.Any(h => h.HasExposeAsEndpointAttribute());
        }

        /// <summary>
        /// Generates endpoint metadata registration code for all discovered endpoints.
        /// </summary>
        /// <param name="handlers">The handler methods discovered by HandlerDiscovery.</param>
        /// <returns>The generated source code for endpoint metadata registration.</returns>
        /// <remarks>
        /// Legacy method maintained for backward compatibility.
        /// New code should use Generate() from ICodeGenerator interface.
        /// </remarks>
        public string GenerateEndpointMetadata(IEnumerable<HandlerInfo> handlers)
        {
            var endpointMethods = handlers
                .Where(h => h.HasExposeAsEndpointAttribute())
                .ToList();

            if (!endpointMethods.Any())
            {
                return string.Empty;
            }

            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("#nullable enable");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine("using System.Collections.Generic;");
            sourceBuilder.AppendLine("using Relay.Core;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("namespace Relay.Generated");
            sourceBuilder.AppendLine("{");
            sourceBuilder.AppendLine("    /// <summary>");
            sourceBuilder.AppendLine("    /// Generated endpoint metadata registrations.");
            sourceBuilder.AppendLine("    /// </summary>");
            sourceBuilder.AppendLine("    internal static class GeneratedEndpointMetadata");
            sourceBuilder.AppendLine("    {");
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Registers all generated endpoint metadata.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        public static void RegisterEndpoints()");
            sourceBuilder.AppendLine("        {");

            foreach (var handler in endpointMethods)
            {
                GenerateEndpointRegistration(sourceBuilder, handler);
            }

            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine("    }");
            sourceBuilder.AppendLine("}");

            return sourceBuilder.ToString();
        }

        private void GenerateEndpointRegistration(StringBuilder sourceBuilder, HandlerInfo handler)
        {
            var endpointAttribute = handler.GetExposeAsEndpointAttribute();
            if (endpointAttribute == null || handler.MethodSymbol == null) return;

            var requestType = GetRequestType(handler.MethodSymbol);
            var responseType = GetResponseType(handler.MethodSymbol);
            var handlerType = handler.MethodSymbol.ContainingType;

            // Extract attribute values
            var route = GetAttributeValue(endpointAttribute, "Route") ?? GenerateDefaultRoute(requestType);
            var httpMethod = GetAttributeValue(endpointAttribute, "HttpMethod") ?? "POST";
            var version = GetAttributeValue(endpointAttribute, "Version");

            sourceBuilder.AppendLine("            // Endpoint for " + handler.MethodSymbol.Name);
            sourceBuilder.AppendLine("            EndpointMetadataRegistry.RegisterEndpoint(new EndpointMetadata");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine($"                Route = \"{EscapeString(route)}\",");
            sourceBuilder.AppendLine($"                HttpMethod = \"{EscapeString(httpMethod)}\",");

            if (!string.IsNullOrWhiteSpace(version))
            {
                sourceBuilder.AppendLine($"                Version = \"{EscapeString(version)}\",");
            }

            sourceBuilder.AppendLine($"                RequestType = typeof({FormatType(requestType)}),");

            if (responseType != null && !IsVoidType(responseType))
            {
                sourceBuilder.AppendLine($"                ResponseType = typeof({FormatType(responseType)}),");
            }

            sourceBuilder.AppendLine($"                HandlerType = typeof({handlerType.ToDisplayString()}),");
            sourceBuilder.AppendLine($"                HandlerMethodName = \"{handler.MethodSymbol.Name}\",");

            // Generate JSON schemas
            GenerateJsonSchemas(sourceBuilder, requestType, responseType);

            sourceBuilder.AppendLine("            });");
            sourceBuilder.AppendLine();
        }

        private void GenerateJsonSchemas(StringBuilder sourceBuilder, ITypeSymbol requestType, ITypeSymbol? responseType)
        {
            // Generate request schema
            var requestSchema = JsonSchemaGenerator.GenerateSchema(requestType, _compilation);
            sourceBuilder.AppendLine("                RequestSchema = new JsonSchemaContract");
            sourceBuilder.AppendLine("                {");
            sourceBuilder.AppendLine($"                    Schema = @\"{EscapeJsonString(requestSchema)}\",");
            sourceBuilder.AppendLine("                    ContentType = \"application/json\",");
            sourceBuilder.AppendLine("                    SchemaVersion = \"http://json-schema.org/draft-07/schema#\"");
            sourceBuilder.AppendLine("                },");

            // Generate response schema if response type exists and is not void
            if (responseType != null && !IsVoidType(responseType))
            {
                var responseSchema = JsonSchemaGenerator.GenerateSchema(responseType, _compilation);
                sourceBuilder.AppendLine("                ResponseSchema = new JsonSchemaContract");
                sourceBuilder.AppendLine("                {");
                sourceBuilder.AppendLine($"                    Schema = @\"{EscapeJsonString(responseSchema)}\",");
                sourceBuilder.AppendLine("                    ContentType = \"application/json\",");
                sourceBuilder.AppendLine("                    SchemaVersion = \"http://json-schema.org/draft-07/schema#\"");
                sourceBuilder.AppendLine("                },");
            }
        }

        private string? GetAttributeValue(AttributeData attribute, string propertyName)
        {
            // First try named arguments
            var namedArgument = attribute.NamedArguments
                .FirstOrDefault(arg => arg.Key == propertyName);

            if (namedArgument.Key == propertyName && namedArgument.Value.Value != null)
            {
                return namedArgument.Value.Value.ToString();
            }

            // For backward compatibility, try constructor arguments
            // Some attributes might be parsed differently
            if (attribute.ConstructorArguments.Length > 0)
            {
                // For ExposeAsEndpoint, Route is first, HttpMethod is second
                if (propertyName == "Route" && attribute.ConstructorArguments.Length > 0)
                {
                    return attribute.ConstructorArguments[0].Value?.ToString();
                }
                if (propertyName == "HttpMethod" && attribute.ConstructorArguments.Length > 1)
                {
                    return attribute.ConstructorArguments[1].Value?.ToString();
                }
            }

            return null;
        }

        private string GenerateDefaultRoute(ITypeSymbol requestType)
        {
            var typeName = requestType.Name;

            // Remove common suffixes
            if (typeName.EndsWith("Request"))
            {
                typeName = typeName.Substring(0, typeName.Length - 7);
            }
            else if (typeName.EndsWith("Command"))
            {
                typeName = typeName.Substring(0, typeName.Length - 7);
            }
            else if (typeName.EndsWith("Query"))
            {
                typeName = typeName.Substring(0, typeName.Length - 5);
            }

            // Convert to kebab-case
            return "/" + ToKebabCase(typeName).ToLowerInvariant();
        }

        private string ToKebabCase(string input)
        {
            if (string.IsNullOrWhiteSpace(input))
                return input;

            var result = new StringBuilder();
            for (int i = 0; i < input.Length; i++)
            {
                var c = input[i];
                if (char.IsUpper(c) && i > 0)
                {
                    result.Append('-');
                }
                result.Append(char.ToLowerInvariant(c));
            }
            return result.ToString();
        }

        private bool IsVoidType(ITypeSymbol typeSymbol)
        {
            return typeSymbol.SpecialType == SpecialType.System_Void;
        }

        private string EscapeString(string? input)
        {
            if (input == null) return string.Empty;
            return input.Replace("\"", "\\\"").Replace("\\", "\\\\");
        }

        private string EscapeJsonString(string json)
        {
            return json.Replace("\"", "\\\"").Replace("\r\n", "\\r\\n").Replace("\n", "\\n");
        }

        private ITypeSymbol GetRequestType(IMethodSymbol method)
        {
            return method.Parameters.FirstOrDefault()?.Type ??
                   _compilation.GetSpecialType(SpecialType.System_Object);
        }

        private ITypeSymbol? GetResponseType(IMethodSymbol method)
        {
            var returnType = method.ReturnType;

            // Handle Task<T> and ValueTask<T>
            if (returnType is INamedTypeSymbol namedType)
            {
                if (namedType.IsGenericType &&
                    namedType.ContainingNamespace?.ToDisplayString() == "System.Threading.Tasks" &&
                    (namedType.Name == "Task" || namedType.Name == "ValueTask"))
                {
                    return namedType.TypeArguments.FirstOrDefault();
                }
            }

            // Handle non-async return types (direct return)
            if (returnType.SpecialType != SpecialType.System_Void)
            {
                if (returnType is INamedTypeSymbol nt)
                {
                    var isTaskLike = nt.ContainingNamespace?.ToDisplayString() == "System.Threading.Tasks" && (nt.Name == "Task" || nt.Name == "ValueTask");
                    if (!isTaskLike)
                    {
                        return returnType;
                    }
                }
                else
                {
                    return returnType;
                }
            }

            return null;
        }

        private string FormatType(ITypeSymbol type)
        {
            var format = SymbolDisplayFormat.MinimallyQualifiedFormat.WithMiscellaneousOptions(
                SymbolDisplayFormat.MinimallyQualifiedFormat.MiscellaneousOptions |
                SymbolDisplayMiscellaneousOptions.UseSpecialTypes);
            return type.ToDisplayString(format);
        }

        /// <inheritdoc/>
        protected override void AppendUsings(StringBuilder builder, HandlerDiscoveryResult result, GenerationOptions options)
        {
            builder.AppendLine("using System;");
            builder.AppendLine("using System.Collections.Generic;");
            builder.AppendLine("using Relay.Core;");
        }

        /// <inheritdoc/>
        protected override void GenerateContent(StringBuilder builder, HandlerDiscoveryResult result, GenerationOptions options)
        {
            var endpointMethods = result.Handlers
                .Where(h => h.HasExposeAsEndpointAttribute())
                .ToList();

            // Generate endpoint metadata class
            AppendIndented(builder, 1, "/// <summary>");
            AppendIndented(builder, 1, "/// Generated endpoint metadata registrations.");
            AppendIndented(builder, 1, "/// </summary>");
            AppendIndented(builder, 1, "internal static class GeneratedEndpointMetadata");
            AppendIndented(builder, 1, "{");
            AppendIndented(builder, 2, "/// <summary>");
            AppendIndented(builder, 2, "/// Registers all generated endpoint metadata.");
            AppendIndented(builder, 2, "/// </summary>");
            AppendIndented(builder, 2, "public static void RegisterEndpoints()");
            AppendIndented(builder, 2, "{");

            foreach (var handler in endpointMethods)
            {
                GenerateEndpointRegistration(builder, handler);
            }

            AppendIndented(builder, 2, "}");
            AppendIndented(builder, 1, "}");
        }
    }
}