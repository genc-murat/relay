using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis;
using Relay.SourceGenerator.Diagnostics;

namespace Relay.SourceGenerator.Generators
{
    /// <summary>
    /// Provides fallback implementations when optimal code generation fails or no handlers are found.
    /// Ensures minimal functionality is always available even in error scenarios.
    /// </summary>
    public static class FallbackGenerator
    {
        /// <summary>
        /// Generates a basic AddRelay extension method when no handlers are found.
        /// This ensures the application can still compile and run with basic Relay functionality.
        /// </summary>
        /// <param name="options">Generation options</param>
        /// <returns>Generated source code for basic AddRelay method</returns>
        public static string GenerateBasicAddRelay(GenerationOptions options)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// Generated by Relay.SourceGenerator - Fallback Implementation");
            sb.AppendLine("// No handlers were found, providing basic Relay services registration");
            sb.AppendLine();

            if (options.EnableNullableContext)
            {
                sb.AppendLine("#nullable enable");
                sb.AppendLine();
            }

            sb.AppendLine("using System;");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection.Extensions;");
            sb.AppendLine();

            var ns = options.CustomNamespace ?? "Microsoft.Extensions.DependencyInjection";
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");

            if (options.IncludeDocumentation)
            {
                sb.AppendLine("    /// <summary>");
                sb.AppendLine("    /// Extension methods for registering Relay services with the DI container.");
                sb.AppendLine("    /// This is a fallback implementation generated when no handlers are found.");
                sb.AppendLine("    /// </summary>");
            }

            sb.AppendLine("    public static partial class RelayServiceCollectionExtensions");
            sb.AppendLine("    {");

            if (options.IncludeDocumentation)
            {
                sb.AppendLine("        /// <summary>");
                sb.AppendLine("        /// Registers basic Relay services with the DI container.");
                sb.AppendLine("        /// Note: No handlers were found. Add [Handle] or [Notification] attributes to your handler methods.");
                sb.AppendLine("        /// </summary>");
                sb.AppendLine("        /// <param name=\"services\">The service collection.</param>");
                sb.AppendLine("        /// <returns>The service collection for chaining.</returns>");
            }

            sb.AppendLine("        public static IServiceCollection AddRelay(this IServiceCollection services)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (services == null)");
            sb.AppendLine("                throw new ArgumentNullException(nameof(services));");
            sb.AppendLine();
            sb.AppendLine("            // Register core Relay services with fallback implementations");
            sb.AppendLine("            services.TryAddTransient(typeof(Relay.Core.Contracts.Core.IRelay), typeof(Relay.Core.Implementation.Core.RelayImplementation));");
            sb.AppendLine("            services.TryAddTransient(typeof(Relay.Core.Contracts.Dispatchers.IRequestDispatcher), typeof(Relay.Core.Implementation.Fallback.FallbackRequestDispatcher));");
            sb.AppendLine("            services.TryAddTransient(typeof(Relay.Core.Contracts.Dispatchers.IStreamDispatcher), typeof(Relay.Core.Implementation.Dispatchers.StreamDispatcher));");
            sb.AppendLine("            services.TryAddTransient(typeof(Relay.Core.Contracts.Dispatchers.INotificationDispatcher), typeof(Relay.Core.Implementation.Dispatchers.NotificationDispatcher));");
            sb.AppendLine();
            sb.AppendLine("            return services;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Generates a fallback dispatcher when optimized dispatcher generation fails.
        /// This ensures request dispatching still works, albeit without optimizations.
        /// </summary>
        /// <param name="options">Generation options</param>
        /// <param name="errorMessage">Error message explaining why fallback is being used</param>
        /// <returns>Generated source code for fallback dispatcher</returns>
        public static string GenerateFallbackDispatcher(GenerationOptions options, string errorMessage)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// Generated by Relay.SourceGenerator - Fallback Dispatcher");
            sb.AppendLine($"// Reason: {errorMessage}");
            sb.AppendLine("// Using reflection-based fallback dispatcher");
            sb.AppendLine();

            if (options.EnableNullableContext)
            {
                sb.AppendLine("#nullable enable");
                sb.AppendLine();
            }

            sb.AppendLine("using System;");
            sb.AppendLine("using System.Threading;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine();

            var ns = options.CustomNamespace ?? "Relay.Generated";
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");

            if (options.IncludeDocumentation)
            {
                sb.AppendLine("    /// <summary>");
                sb.AppendLine("    /// Fallback request dispatcher using reflection.");
                sb.AppendLine("    /// This dispatcher is used when optimized code generation fails.");
                sb.AppendLine("    /// </summary>");
            }

            sb.AppendLine("    public class GeneratedRequestDispatcher : Relay.Core.Implementation.Fallback.FallbackRequestDispatcher");
            sb.AppendLine("    {");
            sb.AppendLine("        public GeneratedRequestDispatcher(IServiceProvider serviceProvider)");
            sb.AppendLine("            : base(serviceProvider)");
            sb.AppendLine("        {");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Generates a minimal handler registry when handler discovery fails.
        /// </summary>
        /// <param name="options">Generation options</param>
        /// <returns>Generated source code for minimal handler registry</returns>
        public static string GenerateMinimalHandlerRegistry(GenerationOptions options)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("// Generated by Relay.SourceGenerator - Minimal Handler Registry");
            sb.AppendLine("// Fallback implementation with no registered handlers");
            sb.AppendLine();

            if (options.EnableNullableContext)
            {
                sb.AppendLine("#nullable enable");
                sb.AppendLine();
            }

            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine();

            var ns = options.CustomNamespace ?? "Relay.Generated";
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");

            if (options.IncludeDocumentation)
            {
                sb.AppendLine("    /// <summary>");
                sb.AppendLine("    /// Minimal handler registry with no registered handlers.");
                sb.AppendLine("    /// </summary>");
            }

            sb.AppendLine("    public static class HandlerRegistry");
            sb.AppendLine("    {");
            sb.AppendLine("        public static IReadOnlyDictionary<Type, Type> RequestHandlers { get; } = new Dictionary<Type, Type>();");
            sb.AppendLine("        public static IReadOnlyDictionary<Type, List<Type>> NotificationHandlers { get; } = new Dictionary<Type, List<Type>>();");
            sb.AppendLine("        public static IReadOnlyDictionary<Type, Type> StreamHandlers { get; } = new Dictionary<Type, Type>();");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        /// <summary>
        /// Determines if fallback generation should be used based on error conditions.
        /// </summary>
        /// <param name="exception">The exception that occurred</param>
        /// <returns>True if fallback should be used, false if error should be reported</returns>
        public static bool ShouldUseFallback(Exception exception)
        {
            // Use fallback for known recoverable errors
            return exception is not OperationCanceledException &&
                   exception is not OutOfMemoryException &&
                   exception is not StackOverflowException;
        }

        /// <summary>
        /// Reports that a fallback implementation is being used.
        /// </summary>
        /// <param name="diagnosticReporter">Diagnostic reporter</param>
        /// <param name="reason">Reason for using fallback</param>
        public static void ReportFallbackUsage(IDiagnosticReporter diagnosticReporter, string reason)
        {
            var diagnostic = Diagnostic.Create(
                DiagnosticDescriptors.Info,
                Location.None,
                $"Using fallback implementation: {reason}");
            diagnosticReporter.ReportDiagnostic(diagnostic);
        }

        /// <summary>
        /// Generates a complete fallback solution when all generation fails.
        /// This ensures the project can still compile.
        /// </summary>
        /// <param name="options">Generation options</param>
        /// <param name="diagnosticReporter">Diagnostic reporter</param>
        /// <returns>Dictionary of filename to source code</returns>
        public static Dictionary<string, string> GenerateCompleteFallback(
            GenerationOptions options,
            IDiagnosticReporter diagnosticReporter)
        {
            ReportFallbackUsage(diagnosticReporter, "Complete generation failure, using minimal fallback");

            var sources = new Dictionary<string, string>
            {
                ["RelayRegistration.g.cs"] = GenerateBasicAddRelay(options),
                ["HandlerRegistry.g.cs"] = GenerateMinimalHandlerRegistry(options)
            };

            // Only generate fallback dispatcher if optimized dispatcher is enabled
            if (options.EnableOptimizedDispatcher)
            {
                sources["OptimizedRequestDispatcher.g.cs"] = GenerateFallbackDispatcher(
                    options,
                    "Optimized dispatcher generation failed");
            }

            return sources;
        }

        /// <summary>
        /// Validates that fallback generation options are valid.
        /// </summary>
        /// <param name="options">Generation options to validate</param>
        /// <returns>True if valid, false otherwise</returns>
        public static bool ValidateFallbackOptions(GenerationOptions? options)
        {
            if (options == null)
            {
                return false;
            }

            // Fallback generation has minimal requirements
            // Just ensure options object is not null
            return true;
        }
    }
}
