using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Relay.SourceGenerator.Generators;

/// <summary>
/// Generates optimized dispatch methods for maximum performance.
/// Implements the Strategy pattern via ICodeGenerator interface.
/// </summary>
public class OptimizedDispatcherGenerator : BaseCodeGenerator
{
    private readonly RelayCompilationContext _context;

    public OptimizedDispatcherGenerator(RelayCompilationContext context)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
    }

    /// <inheritdoc/>
    public override string GeneratorName => "Optimized Dispatcher Generator";

    /// <inheritdoc/>
    public override string OutputFileName => "OptimizedDispatcher";

    /// <inheritdoc/>
    public override int Priority => 30; // Run after DI registration and handler registry

    /// <summary>
    /// Generates optimized dispatcher source code with specialized methods for each request type
    /// </summary>
    /// <remarks>
    /// Legacy method maintained for backward compatibility.
    /// New code should use Generate() from ICodeGenerator interface.
    /// </remarks>
    public string GenerateOptimizedDispatcher(HandlerDiscoveryResult discoveryResult)
    {
        var sourceBuilder = new StringBuilder();

        // File header
        sourceBuilder.AppendLine("// <auto-generated />");
        sourceBuilder.AppendLine("// Generated by Relay.SourceGenerator - Optimized Dispatcher");
        sourceBuilder.AppendLine($"// Generation time: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        sourceBuilder.AppendLine();

        // Usings
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine("using System.Collections.Generic;");
        sourceBuilder.AppendLine("using System.Runtime.CompilerServices;");
        sourceBuilder.AppendLine("using System.Threading;");
        sourceBuilder.AppendLine("using System.Threading.Tasks;");
        sourceBuilder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sourceBuilder.AppendLine("using Relay.Core;");
        sourceBuilder.AppendLine();

        // Namespace
        sourceBuilder.AppendLine("namespace Relay.Generated");
        sourceBuilder.AppendLine("{");

        // Generate optimized dispatcher class
        GenerateOptimizedDispatcherClass(sourceBuilder, discoveryResult);

        sourceBuilder.AppendLine("}");

        return sourceBuilder.ToString();
    }

    private void GenerateOptimizedDispatcherClass(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
    {
        sourceBuilder.AppendLine("    /// <summary>");
        sourceBuilder.AppendLine("    /// High-performance dispatcher with specialized methods for each request type");
        sourceBuilder.AppendLine("    /// </summary>");
        sourceBuilder.AppendLine("    public static class OptimizedDispatcher");
        sourceBuilder.AppendLine("    {");

        // Generate type-specific dispatch methods
        GenerateTypeSpecificDispatchMethods(sourceBuilder, discoveryResult);

        // Generate main dispatch method with branch prediction optimization
        GenerateMainDispatchMethod(sourceBuilder, discoveryResult);

        // Generate streaming dispatch methods
        GenerateStreamingDispatchMethods(sourceBuilder, discoveryResult);

        // Generate notification dispatch methods
        GenerateNotificationDispatchMethods(sourceBuilder, discoveryResult);

        sourceBuilder.AppendLine("    }");
    }

    private void GenerateTypeSpecificDispatchMethods(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
    {
        var requestHandlers = discoveryResult.Handlers
            .Where(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Handle) && h.MethodSymbol != null && h.MethodSymbol.Parameters.Length > 0)
            .GroupBy(h => h.MethodSymbol!.Parameters[0].Type.ToDisplayString())
            .ToList();

        foreach (var group in requestHandlers)
        {
            var requestType = group.Key;
            var handlers = group.ToList();

            // Generate specialized dispatch method for this request type
            GenerateSpecializedDispatchMethod(sourceBuilder, requestType, handlers);
        }
    }

    private void GenerateSpecializedDispatchMethod(StringBuilder sourceBuilder, string requestType, List<HandlerInfo> handlers)
    {
        var responseType = GetResponseType(handlers.First());
        var methodName = $"Dispatch_{SanitizeTypeName(requestType)}";

        sourceBuilder.AppendLine($"        /// <summary>");
        sourceBuilder.AppendLine($"        /// Specialized dispatch method for {requestType}");
        sourceBuilder.AppendLine($"        /// Uses aggressive inlining for maximum performance.");
        sourceBuilder.AppendLine($"        /// </summary>");
        sourceBuilder.AppendLine($"        /// <param name=\"request\">The request to dispatch.</param>");
        sourceBuilder.AppendLine($"        /// <param name=\"serviceProvider\">The service provider for dependency resolution.</param>");
        sourceBuilder.AppendLine($"        /// <param name=\"handlerName\">Optional handler name for named handler selection.</param>");
        sourceBuilder.AppendLine($"        /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sourceBuilder.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");

        if (responseType == "void")
        {
            sourceBuilder.AppendLine($"        public static async ValueTask {methodName}(");
        }
        else
        {
            sourceBuilder.AppendLine($"        public static async ValueTask<{responseType}> {methodName}(");
        }

        sourceBuilder.AppendLine($"            {requestType} request,");
        sourceBuilder.AppendLine($"            IServiceProvider serviceProvider,");
        sourceBuilder.AppendLine($"            string? handlerName = null,");
        sourceBuilder.AppendLine($"            CancellationToken cancellationToken = default)");
        sourceBuilder.AppendLine($"        {{");

        // Generate optimized handler selection with branch prediction
        if (handlers.Count == 1)
        {
            // Single handler - direct invocation (most common case, optimized for branch prediction)
            GenerateSingleHandlerInvocation(sourceBuilder, handlers.First(), responseType);
        }
        else
        {
            // Multiple handlers - optimized selection with pattern matching
            GenerateMultipleHandlerSelection(sourceBuilder, handlers, responseType);
        }

        sourceBuilder.AppendLine($"        }}");
        sourceBuilder.AppendLine();
    }

    private void GenerateSingleHandlerInvocation(StringBuilder sourceBuilder, HandlerInfo handler, string responseType)
    {
        if (handler.MethodSymbol == null) return;
        var handlerType = handler.MethodSymbol.ContainingType.ToDisplayString();
        var methodName = handler.MethodSymbol.Name;
        var isStatic = handler.MethodSymbol.IsStatic;

        sourceBuilder.AppendLine($"            // Direct invocation for single handler - maximum performance");
        sourceBuilder.AppendLine($"            // Branch prediction optimized: most common path (single handler) executes first");

        if (isStatic)
        {
            // Static method invocation - no DI overhead
            if (responseType == "void")
            {
                sourceBuilder.AppendLine($"            await {handlerType}.{methodName}(request, cancellationToken).ConfigureAwait(false);");
            }
            else
            {
                sourceBuilder.AppendLine($"            return await {handlerType}.{methodName}(request, cancellationToken).ConfigureAwait(false);");
            }
        }
        else
        {
            // Instance method invocation - resolve from DI
            sourceBuilder.AppendLine($"            var handler = serviceProvider.GetRequiredService<{handlerType}>();");
            if (responseType == "void")
            {
                sourceBuilder.AppendLine($"            await handler.{methodName}(request, cancellationToken).ConfigureAwait(false);");
            }
            else
            {
                sourceBuilder.AppendLine($"            return await handler.{methodName}(request, cancellationToken).ConfigureAwait(false);");
            }
        }
    }

    private void GenerateMultipleHandlerSelection(StringBuilder sourceBuilder, List<HandlerInfo> handlers, string responseType)
    {
        sourceBuilder.AppendLine($"            // Optimized handler selection with pattern matching");
        sourceBuilder.AppendLine($"            // Branch prediction optimized: default handler first (most common case)");

        // Sort handlers by priority and put default handler first (most common case)
        var sortedHandlers = handlers
            .OrderByDescending(h => GetHandlerPriority(h))
            .ThenBy(h => GetHandlerName(h) == "default" ? 0 : 1)
            .ToList();

        // Check if we can use keyed services (.NET 8+)
        var hasNamedHandlers = sortedHandlers.Any(h => GetHandlerName(h) != "default");
        
        if (hasNamedHandlers)
        {
            // Use pattern matching switch expression for named handlers
            sourceBuilder.AppendLine($"            // Pattern matching for O(1) handler selection");
            sourceBuilder.AppendLine($"            return handlerName switch");
            sourceBuilder.AppendLine($"            {{");

            foreach (var handler in sortedHandlers)
            {
                if (handler.MethodSymbol == null) continue;
                var handlerName = GetHandlerName(handler);
                var handlerType = handler.MethodSymbol.ContainingType.ToDisplayString();
                var methodName = handler.MethodSymbol.Name;
                var isStatic = handler.MethodSymbol.IsStatic;

                var pattern = handlerName == "default"
                    ? "null or \"default\""
                    : $"\"{handlerName}\"";

                if (isStatic)
                {
                    if (responseType == "void")
                    {
                        sourceBuilder.AppendLine($"                {pattern} => {handlerType}.{methodName}(request, cancellationToken),");
                    }
                    else
                    {
                        sourceBuilder.AppendLine($"                {pattern} => {handlerType}.{methodName}(request, cancellationToken),");
                    }
                }
                else
                {
                    // For instance methods, we need to resolve and invoke
                    sourceBuilder.AppendLine($"                {pattern} => InvokeHandler_{SanitizeTypeName(handlerType)}_{methodName}(serviceProvider, request, cancellationToken),");
                }
            }

            var requestTypeName = handlers.FirstOrDefault()?.MethodSymbol?.Parameters.FirstOrDefault()?.Type?.ToDisplayString() ?? "Unknown";
            sourceBuilder.AppendLine($"                _ => throw new InvalidOperationException($\"No handler found with name '{{handlerName}}' for request type '{requestTypeName.Replace("\"", "\\\"")}'.\")");
            sourceBuilder.AppendLine($"            }};");

            // Generate helper methods for instance handlers
            foreach (var handler in sortedHandlers.Where(h => h.MethodSymbol != null && !h.MethodSymbol.IsStatic))
            {
                if (handler.MethodSymbol == null) continue;
                var handlerType = handler.MethodSymbol.ContainingType.ToDisplayString();
                var methodName = handler.MethodSymbol.Name;
                var requestType = handler.MethodSymbol.Parameters[0].Type.ToDisplayString();
                
                sourceBuilder.AppendLine();
                sourceBuilder.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                
                if (responseType == "void")
                {
                    sourceBuilder.AppendLine($"        private static async ValueTask InvokeHandler_{SanitizeTypeName(handlerType)}_{methodName}(");
                }
                else
                {
                    sourceBuilder.AppendLine($"        private static async ValueTask<{responseType}> InvokeHandler_{SanitizeTypeName(handlerType)}_{methodName}(");
                }
                
                sourceBuilder.AppendLine($"            IServiceProvider serviceProvider,");
                sourceBuilder.AppendLine($"            {requestType} request,");
                sourceBuilder.AppendLine($"            CancellationToken cancellationToken)");
                sourceBuilder.AppendLine($"        {{");
                sourceBuilder.AppendLine($"            var handler = serviceProvider.GetRequiredService<{handlerType}>();");
                
                if (responseType == "void")
                {
                    sourceBuilder.AppendLine($"            await handler.{methodName}(request, cancellationToken).ConfigureAwait(false);");
                }
                else
                {
                    sourceBuilder.AppendLine($"            return await handler.{methodName}(request, cancellationToken).ConfigureAwait(false);");
                }
                
                sourceBuilder.AppendLine($"        }}");
            }
        }
        else
        {
            // Fallback to if-else for simple cases
            bool isFirst = true;
            foreach (var handler in sortedHandlers)
            {
                if (handler.MethodSymbol == null) continue;
                var handlerName = GetHandlerName(handler);
                var handlerType = handler.MethodSymbol.ContainingType.ToDisplayString();
                var methodName = handler.MethodSymbol.Name;
                var isStatic = handler.MethodSymbol.IsStatic;

                var condition = handlerName == "default"
                    ? "handlerName == null || handlerName == \"default\""
                    : $"handlerName == \"{handlerName}\"";

                var keyword = isFirst ? "if" : "else if";
                sourceBuilder.AppendLine($"            {keyword} ({condition})");
                sourceBuilder.AppendLine($"            {{");

                if (isStatic)
                {
                    if (responseType == "void")
                    {
                        sourceBuilder.AppendLine($"                await {handlerType}.{methodName}(request, cancellationToken).ConfigureAwait(false);");
                        sourceBuilder.AppendLine($"                return;");
                    }
                    else
                    {
                        sourceBuilder.AppendLine($"                return await {handlerType}.{methodName}(request, cancellationToken).ConfigureAwait(false);");
                    }
                }
                else
                {
                    sourceBuilder.AppendLine($"                var handler = serviceProvider.GetRequiredService<{handlerType}>();");
                    if (responseType == "void")
                    {
                        sourceBuilder.AppendLine($"                await handler.{methodName}(request, cancellationToken).ConfigureAwait(false);");
                        sourceBuilder.AppendLine($"                return;");
                    }
                    else
                    {
                        sourceBuilder.AppendLine($"                return await handler.{methodName}(request, cancellationToken).ConfigureAwait(false);");
                    }
                }

                sourceBuilder.AppendLine($"            }}");
                isFirst = false;
            }

            // Generate fallback for unknown handler names
            var requestTypeName = handlers.FirstOrDefault()?.MethodSymbol?.Parameters.FirstOrDefault()?.Type?.ToDisplayString() ?? "Unknown";
            sourceBuilder.AppendLine($"            else");
            sourceBuilder.AppendLine($"            {{");
            sourceBuilder.AppendLine($"                throw new InvalidOperationException($\"No handler found with name '{{handlerName}}' for request type '{requestTypeName.Replace("\"", "\\\"")}'.\");");
            sourceBuilder.AppendLine($"            }}");
        }
    }

    private void GenerateMainDispatchMethod(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
    {
        sourceBuilder.AppendLine($"        /// <summary>");
        sourceBuilder.AppendLine($"        /// Main dispatch method with pattern matching for O(1) type lookup.");
        sourceBuilder.AppendLine($"        /// Uses aggressive inlining and type-safe dispatch without reflection.");
        sourceBuilder.AppendLine($"        /// </summary>");
        sourceBuilder.AppendLine($"        /// <typeparam name=\"TRequest\">The request type.</typeparam>");
        sourceBuilder.AppendLine($"        /// <typeparam name=\"TResponse\">The response type.</typeparam>");
        sourceBuilder.AppendLine($"        /// <param name=\"request\">The request to dispatch.</param>");
        sourceBuilder.AppendLine($"        /// <param name=\"serviceProvider\">The service provider for dependency resolution.</param>");
        sourceBuilder.AppendLine($"        /// <param name=\"handlerName\">Optional handler name for named handler selection.</param>");
        sourceBuilder.AppendLine($"        /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sourceBuilder.AppendLine($"        /// <returns>The handler response.</returns>");
        sourceBuilder.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sourceBuilder.AppendLine($"        public static async ValueTask<TResponse> DispatchAsync<TRequest, TResponse>(");
        sourceBuilder.AppendLine($"            TRequest request,");
        sourceBuilder.AppendLine($"            IServiceProvider serviceProvider,");
        sourceBuilder.AppendLine($"            string? handlerName = null,");
        sourceBuilder.AppendLine($"            CancellationToken cancellationToken = default)");
        sourceBuilder.AppendLine($"        {{");

        // Generate type-specific dispatch calls with pattern matching
        var requestTypes = discoveryResult.Handlers
            .Where(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Handle) && h.MethodSymbol != null && h.MethodSymbol.Parameters.Length > 0)
            .Select(h => h.MethodSymbol!.Parameters[0].Type.ToDisplayString())
            .Distinct()
            .OrderBy(t => t) // Consistent ordering for better branch prediction
            .ToList();

        if (requestTypes.Count > 0)
        {
            sourceBuilder.AppendLine($"            // Pattern matching switch expression for O(1) type lookup");
            sourceBuilder.AppendLine($"            // Branch prediction optimized: most common types should be first");
            sourceBuilder.AppendLine($"            return request switch");
            sourceBuilder.AppendLine($"            {{");

            foreach (var requestType in requestTypes)
            {
                var methodName = $"Dispatch_{SanitizeTypeName(requestType)}";
                sourceBuilder.AppendLine($"                {requestType} r => (TResponse)(object)(await {methodName}(r, serviceProvider, handlerName, cancellationToken))!,");
            }

            sourceBuilder.AppendLine($"                _ => throw new InvalidOperationException($\"No handler found for request type '{{typeof(TRequest).Name}}'.\")");
            sourceBuilder.AppendLine($"            }};");
        }
        else
        {
            sourceBuilder.AppendLine($"            throw new InvalidOperationException($\"No handlers registered.\");");
        }

        sourceBuilder.AppendLine($"        }}");
        sourceBuilder.AppendLine();
    }

    private void GenerateStreamingDispatchMethods(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
    {
        var streamHandlers = discoveryResult.Handlers
            .Where(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Handle) &&
                       h.MethodSymbol != null && h.MethodSymbol.ReturnType.ToDisplayString().Contains("IAsyncEnumerable"))
            .ToList();

        if (!streamHandlers.Any()) return;

        sourceBuilder.AppendLine($"        /// <summary>");
        sourceBuilder.AppendLine($"        /// Optimized streaming dispatch method with IAsyncEnumerable support.");
        sourceBuilder.AppendLine($"        /// Uses pattern matching for O(1) type lookup and aggressive inlining.");
        sourceBuilder.AppendLine($"        /// </summary>");
        sourceBuilder.AppendLine($"        /// <typeparam name=\"TRequest\">The stream request type.</typeparam>");
        sourceBuilder.AppendLine($"        /// <typeparam name=\"TResponse\">The stream response type.</typeparam>");
        sourceBuilder.AppendLine($"        /// <param name=\"request\">The stream request to dispatch.</param>");
        sourceBuilder.AppendLine($"        /// <param name=\"serviceProvider\">The service provider for dependency resolution.</param>");
        sourceBuilder.AppendLine($"        /// <param name=\"handlerName\">Optional handler name for named handler selection.</param>");
        sourceBuilder.AppendLine($"        /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sourceBuilder.AppendLine($"        /// <returns>An async enumerable of responses.</returns>");
        sourceBuilder.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sourceBuilder.AppendLine($"        public static IAsyncEnumerable<TResponse> DispatchStreamAsync<TRequest, TResponse>(");
        sourceBuilder.AppendLine($"            TRequest request,");
        sourceBuilder.AppendLine($"            IServiceProvider serviceProvider,");
        sourceBuilder.AppendLine($"            string? handlerName = null,");
        sourceBuilder.AppendLine($"            CancellationToken cancellationToken = default)");
        sourceBuilder.AppendLine($"            where TRequest : IStreamRequest<TResponse>");
        sourceBuilder.AppendLine($"        {{");

        // Generate streaming dispatch logic with pattern matching
        sourceBuilder.AppendLine($"            // Pattern matching switch expression for O(1) streaming handler lookup");
        sourceBuilder.AppendLine($"            return request switch");
        sourceBuilder.AppendLine($"            {{");

        foreach (var handler in streamHandlers)
        {
            if (handler.MethodSymbol == null || handler.MethodSymbol.Parameters.Length == 0) continue;
            var requestType = handler.MethodSymbol.Parameters[0].Type.ToDisplayString();
            var handlerType = handler.MethodSymbol.ContainingType.ToDisplayString();
            var methodName = handler.MethodSymbol.Name;
            var isStatic = handler.MethodSymbol.IsStatic;

            if (isStatic)
            {
                sourceBuilder.AppendLine($"                {requestType} r => {handlerType}.{methodName}(r, cancellationToken).Cast<TResponse>(),");
            }
            else
            {
                sourceBuilder.AppendLine($"                {requestType} r => serviceProvider.GetRequiredService<{handlerType}>().{methodName}(r, cancellationToken).Cast<TResponse>(),");
            }
        }

        sourceBuilder.AppendLine($"                _ => throw new InvalidOperationException($\"No streaming handler found for request type '{{typeof(TRequest).Name}}'.\")");
        sourceBuilder.AppendLine($"            }};");
        sourceBuilder.AppendLine($"        }}");
        sourceBuilder.AppendLine();
    }

    private void GenerateNotificationDispatchMethods(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
    {
        var notificationHandlers = discoveryResult.Handlers
            .Where(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Notification))
            .ToList();

        if (!notificationHandlers.Any()) return;

        sourceBuilder.AppendLine($"        /// <summary>");
        sourceBuilder.AppendLine($"        /// Optimized notification dispatch method with parallel execution support.");
        sourceBuilder.AppendLine($"        /// All notification handlers are executed in parallel for maximum throughput.");
        sourceBuilder.AppendLine($"        /// Uses pattern matching for O(1) type lookup and aggressive inlining.");
        sourceBuilder.AppendLine($"        /// </summary>");
        sourceBuilder.AppendLine($"        /// <typeparam name=\"TNotification\">The notification type.</typeparam>");
        sourceBuilder.AppendLine($"        /// <param name=\"notification\">The notification to dispatch.</param>");
        sourceBuilder.AppendLine($"        /// <param name=\"serviceProvider\">The service provider for dependency resolution.</param>");
        sourceBuilder.AppendLine($"        /// <param name=\"cancellationToken\">Cancellation token.</param>");
        sourceBuilder.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sourceBuilder.AppendLine($"        public static async ValueTask DispatchNotificationAsync<TNotification>(");
        sourceBuilder.AppendLine($"            TNotification notification,");
        sourceBuilder.AppendLine($"            IServiceProvider serviceProvider,");
        sourceBuilder.AppendLine($"            CancellationToken cancellationToken = default)");
        sourceBuilder.AppendLine($"            where TNotification : INotification");
        sourceBuilder.AppendLine($"        {{");

        // Group notification handlers by type
        var notificationGroups = notificationHandlers
            .Where(h => h.MethodSymbol != null && h.MethodSymbol.Parameters.Length > 0)
            .GroupBy(h => h.MethodSymbol!.Parameters[0].Type.ToDisplayString())
            .ToList();

        sourceBuilder.AppendLine($"            // Pattern matching for O(1) notification type lookup");
        sourceBuilder.AppendLine($"            switch (notification)");
        sourceBuilder.AppendLine($"            {{");

        foreach (var group in notificationGroups)
        {
            var notificationType = group.Key;
            var handlers = group.ToList();

            sourceBuilder.AppendLine($"                case {notificationType} n:");
            sourceBuilder.AppendLine($"                {{");
            
            // Sort handlers by priority for priority-based notification handling
            var sortedHandlers = handlers
                .OrderByDescending(h => GetHandlerPriority(h))
                .ToList();

            if (sortedHandlers.Count == 1)
            {
                // Single handler - direct invocation
                var handler = sortedHandlers.First();
                if (handler.MethodSymbol == null) continue;
                var handlerType = handler.MethodSymbol.ContainingType.ToDisplayString();
                var methodName = handler.MethodSymbol.Name;
                var isStatic = handler.MethodSymbol.IsStatic;

                sourceBuilder.AppendLine($"                    // Single handler - direct invocation");
                if (isStatic)
                {
                    sourceBuilder.AppendLine($"                    await {handlerType}.{methodName}(n, cancellationToken).ConfigureAwait(false);");
                }
                else
                {
                    sourceBuilder.AppendLine($"                    var handler = serviceProvider.GetRequiredService<{handlerType}>();");
                    sourceBuilder.AppendLine($"                    await handler.{methodName}(n, cancellationToken).ConfigureAwait(false);");
                }
            }
            else
            {
                // Multiple handlers - parallel dispatch
                sourceBuilder.AppendLine($"                    // Multiple handlers - parallel dispatch for maximum throughput");
                sourceBuilder.AppendLine($"                    var tasks = new ValueTask[{sortedHandlers.Count}];");
                
                int taskIndex = 0;
                foreach (var handler in sortedHandlers)
                {
                    if (handler.MethodSymbol == null) continue;
                    var handlerType = handler.MethodSymbol.ContainingType.ToDisplayString();
                    var methodName = handler.MethodSymbol.Name;
                    var isStatic = handler.MethodSymbol.IsStatic;

                    if (isStatic)
                    {
                        sourceBuilder.AppendLine($"                    tasks[{taskIndex}] = {handlerType}.{methodName}(n, cancellationToken);");
                    }
                    else
                    {
                        sourceBuilder.AppendLine($"                    tasks[{taskIndex}] = serviceProvider.GetRequiredService<{handlerType}>().{methodName}(n, cancellationToken);");
                    }
                    taskIndex++;
                }

                sourceBuilder.AppendLine($"                    // Wait for all handlers to complete");
                sourceBuilder.AppendLine($"                    for (int i = 0; i < tasks.Length; i++)");
                sourceBuilder.AppendLine($"                    {{");
                sourceBuilder.AppendLine($"                        await tasks[i].ConfigureAwait(false);");
                sourceBuilder.AppendLine($"                    }}");
            }

            sourceBuilder.AppendLine($"                    break;");
            sourceBuilder.AppendLine($"                }}");
        }

        sourceBuilder.AppendLine($"                default:");
        sourceBuilder.AppendLine($"                    // No handlers found - this is valid for notifications");
        sourceBuilder.AppendLine($"                    break;");
        sourceBuilder.AppendLine($"            }}");
        sourceBuilder.AppendLine($"        }}");
        sourceBuilder.AppendLine();
    }

    private string GetResponseType(HandlerInfo handler)
    {
        if (handler.MethodSymbol == null) return "void";
        var returnType = handler.MethodSymbol.ReturnType;
        var returnTypeString = returnType.ToDisplayString();

        // Handle ValueTask<T>, Task<T>
        if (returnTypeString.StartsWith("System.Threading.Tasks.ValueTask<") ||
            returnTypeString.StartsWith("System.Threading.Tasks.Task<"))
        {
            var genericArgs = ((INamedTypeSymbol)returnType).TypeArguments;
            if (genericArgs.Length > 0)
            {
                return genericArgs[0].ToDisplayString();
            }
        }
        else if (returnTypeString.StartsWith("System.Collections.Generic.IAsyncEnumerable<"))
        {
            // Stream handler
            var genericArgs = ((INamedTypeSymbol)returnType).TypeArguments;
            if (genericArgs.Length > 0)
            {
                return genericArgs[0].ToDisplayString();
            }
        }
        else if (!returnTypeString.Contains("Task") && returnType.SpecialType != SpecialType.System_Void)
        {
            // Direct return type
            return returnTypeString;
        }

        return "void";
    }

    private string GetHandlerName(HandlerInfo handler)
    {
        var handleAttribute = handler.Attributes.FirstOrDefault(a => a.Type == RelayAttributeType.Handle);
        if (handleAttribute?.AttributeData != null)
        {
            var nameArg = handleAttribute.AttributeData.NamedArguments
                .FirstOrDefault(arg => arg.Key == "Name");

            if (nameArg.Value.Value is string name && !string.IsNullOrWhiteSpace(name))
            {
                return name;
            }
        }

        return "default";
    }

    private int GetHandlerPriority(HandlerInfo handler)
    {
        foreach (var attribute in handler.Attributes)
        {
            if (attribute.AttributeData != null)
            {
                var priorityArg = attribute.AttributeData.NamedArguments
                    .FirstOrDefault(arg => arg.Key == "Priority");

                if (priorityArg.Value.Value is int priority)
                {
                    return priority;
                }
            }
        }

        return 0;
    }

    private string SanitizeTypeName(string typeName)
    {
        return typeName
            .Replace(".", "_")
            .Replace("<", "_")
            .Replace(">", "_")
            .Replace(",", "_")
            .Replace(" ", "")
            .Replace("[", "_")
            .Replace("]", "_");
    }

    /// <inheritdoc/>
    protected override void AppendUsings(StringBuilder builder, HandlerDiscoveryResult result, GenerationOptions options)
    {
        builder.AppendLine("using System;");
        builder.AppendLine("using System.Collections.Generic;");
        builder.AppendLine("using System.Linq;");
        builder.AppendLine("using System.Runtime.CompilerServices;");
        builder.AppendLine("using System.Threading;");
        builder.AppendLine("using System.Threading.Tasks;");
        builder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        builder.AppendLine("using Relay.Core;");
    }

    /// <inheritdoc/>
    protected override void GenerateContent(StringBuilder builder, HandlerDiscoveryResult result, GenerationOptions options)
    {
        // Generate optimized dispatcher class
        GenerateOptimizedDispatcherClass(builder, result);
    }
}