using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Relay.SourceGenerator.Generators;

namespace Relay.SourceGenerator
{
    /// <summary>
    /// Generates pipeline registration code for discovered pipeline behaviors.
    /// Implements the Strategy pattern via ICodeGenerator interface.
    /// </summary>
    public class PipelineRegistryGenerator : BaseCodeGenerator
    {
        private readonly RelayCompilationContext _context;

        public PipelineRegistryGenerator(RelayCompilationContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
        }

        /// <inheritdoc/>
        public override string GeneratorName => "Pipeline Registry Generator";

        /// <inheritdoc/>
        public override string OutputFileName => "PipelineRegistry";

        /// <inheritdoc/>
        public override int Priority => 50; // Run after notification dispatcher

        /// <inheritdoc/>
        public override bool CanGenerate(HandlerDiscoveryResult result)
        {
            // Only generate if there are pipeline behaviors
            return result != null && result.Handlers.Any(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Pipeline));
        }

        /// <summary>
        /// Generates the pipeline registry source code.
        /// </summary>
        /// <remarks>
        /// Legacy method maintained for backward compatibility.
        /// New code should use Generate() from ICodeGenerator interface.
        /// </remarks>
        public string GeneratePipelineRegistry(HandlerDiscoveryResult discoveryResult)
        {
            var pipelineHandlers = discoveryResult.Handlers
                .Where(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Pipeline))
                .ToList();

            if (!pipelineHandlers.Any())
            {
                return string.Empty;
            }

            var sourceBuilder = new StringBuilder();

            // File header
            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("// Generated by Relay.SourceGenerator");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine("using System.Collections.Generic;");
            sourceBuilder.AppendLine("using System.Linq;");
            sourceBuilder.AppendLine("using System.Threading;");
            sourceBuilder.AppendLine("using System.Threading.Tasks;");
            sourceBuilder.AppendLine("using Relay.Core;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("namespace Relay.Generated");
            sourceBuilder.AppendLine("{");

            // Generate pipeline registry class
            GeneratePipelineRegistryClass(sourceBuilder, pipelineHandlers);

            sourceBuilder.AppendLine("}");

            return sourceBuilder.ToString();
        }

        private void GeneratePipelineRegistryClass(StringBuilder sourceBuilder, List<HandlerInfo> pipelineHandlers)
        {
            sourceBuilder.AppendLine("    /// <summary>");
            sourceBuilder.AppendLine("    /// Generated pipeline registry for managing pipeline behaviors.");
            sourceBuilder.AppendLine("    /// </summary>");
            sourceBuilder.AppendLine("    internal static class PipelineRegistry");
            sourceBuilder.AppendLine("    {");

            // Generate pipeline metadata
            GeneratePipelineMetadata(sourceBuilder, pipelineHandlers);

            // Generate pipeline discovery methods
            GeneratePipelineDiscoveryMethods(sourceBuilder, pipelineHandlers);

            sourceBuilder.AppendLine("    }");
        }

        private void GeneratePipelineMetadata(StringBuilder sourceBuilder, List<HandlerInfo> pipelineHandlers)
        {
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Pipeline behavior metadata.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        private static readonly PipelineMetadata[] _pipelineMetadata = new[]");
            sourceBuilder.AppendLine("        {");

            foreach (var handler in pipelineHandlers)
            {
                var pipelineAttribute = handler.Attributes.First(a => a.Type == RelayAttributeType.Pipeline);

                // Try to read from AttributeData; if missing, fall back to symbol attributes
                var order = pipelineAttribute.AttributeData != null ? GetAttributeProperty(pipelineAttribute.AttributeData, "Order", 0) : 0;
                var scope = pipelineAttribute.AttributeData != null ? GetAttributeProperty(pipelineAttribute.AttributeData, "Scope", "All") : "All";

                // If mocked AttributeData has empty/invalid values, inspect symbol attributes
                if (pipelineAttribute.AttributeData != null && (pipelineAttribute.AttributeData.NamedArguments.Length == 0 ||
                    pipelineAttribute.AttributeData.NamedArguments.All(kv => kv.Value.IsNull || kv.Value.Value is null)) &&
                    handler.MethodSymbol != null && handler.MethodSymbol.GetAttributes().FirstOrDefault(ad => ad.AttributeClass?.ToDisplayString() == "Relay.Core.PipelineAttribute") is { } symbolAttr)
                {
                    var altOrder = symbolAttr.NamedArguments.FirstOrDefault(kv => kv.Key == "Order").Value.Value;
                    if (altOrder is int i) order = i;
                    var altScope = symbolAttr.NamedArguments.FirstOrDefault(kv => kv.Key == "Scope").Value.Value?.ToString();
                    if (!string.IsNullOrWhiteSpace(altScope)) scope = altScope!;
                }
                else if (order == 0)
                {
                    // As a fallback, try to parse from attribute syntax
                    if (handler.Method != null && TryParsePipelineAttributeFromSyntax(handler.Method, out var parsedOrder, out var parsedScope))
                    {
                        if (parsedOrder.HasValue) order = parsedOrder.Value;
                        if (!string.IsNullOrWhiteSpace(parsedScope)) scope = parsedScope!;
                    }
                }

                if (handler.MethodSymbol == null) continue;
                var containingType = handler.MethodSymbol.ContainingType.ToDisplayString();
                var methodName = handler.MethodSymbol.Name;
                var requestType = GetPipelineRequestType(handler.MethodSymbol);
                var responseType = GetPipelineResponseType(handler.MethodSymbol);
                var isStreamPipeline = IsStreamPipeline(handler.MethodSymbol);

                sourceBuilder.AppendLine($"            new PipelineMetadata");
                sourceBuilder.AppendLine("            {");
                sourceBuilder.AppendLine($"                ContainingType = typeof({containingType}),");
                sourceBuilder.AppendLine($"                MethodName = \"{methodName}\",");
                sourceBuilder.AppendLine($"                RequestType = typeof({requestType}),");
                sourceBuilder.AppendLine($"                ResponseType = typeof({responseType}),");
                sourceBuilder.AppendLine($"                Order = {order},");
                sourceBuilder.AppendLine($"                Scope = PipelineScope.{scope},");
                sourceBuilder.AppendLine($"                IsStreamPipeline = {isStreamPipeline.ToString().ToLowerInvariant()}");
                sourceBuilder.AppendLine("            },");
            }

            sourceBuilder.AppendLine("        };");
            sourceBuilder.AppendLine();
        }

        private void GeneratePipelineDiscoveryMethods(StringBuilder sourceBuilder, List<HandlerInfo> pipelineHandlers)
        {
            // Generate method to get pipeline behaviors for request types
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Gets pipeline behaviors for the specified request type.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        public static IEnumerable<IPipelineBehavior<TRequest, TResponse>> GetPipelineBehaviors<TRequest, TResponse>(IServiceProvider serviceProvider)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            var requestType = typeof(TRequest);");
            sourceBuilder.AppendLine("            var responseType = typeof(TResponse);");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            return _pipelineMetadata");
            sourceBuilder.AppendLine("                .Where(m => !m.IsStreamPipeline && ");
            sourceBuilder.AppendLine("                       (m.Scope == PipelineScope.All || m.Scope == PipelineScope.Requests) &&");
            sourceBuilder.AppendLine("                       IsCompatibleRequestType(m.RequestType, requestType) &&");
            sourceBuilder.AppendLine("                       IsCompatibleResponseType(m.ResponseType, responseType))");
            sourceBuilder.AppendLine("                .OrderBy(m => m.Order)");
            sourceBuilder.AppendLine("                .Select(m => CreatePipelineBehavior<TRequest, TResponse>(m, serviceProvider))");
            sourceBuilder.AppendLine("                .Where(b => b != null)");
            sourceBuilder.AppendLine("                .Cast<IPipelineBehavior<TRequest, TResponse>>();");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            // Generate method to get stream pipeline behaviors
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Gets stream pipeline behaviors for the specified request type.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        public static IEnumerable<IStreamPipelineBehavior<TRequest, TResponse>> GetStreamPipelineBehaviors<TRequest, TResponse>(IServiceProvider serviceProvider)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            var requestType = typeof(TRequest);");
            sourceBuilder.AppendLine("            var responseType = typeof(TResponse);");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            return _pipelineMetadata");
            sourceBuilder.AppendLine("                .Where(m => m.IsStreamPipeline && ");
            sourceBuilder.AppendLine("                       (m.Scope == PipelineScope.All || m.Scope == PipelineScope.Streams) &&");
            sourceBuilder.AppendLine("                       IsCompatibleRequestType(m.RequestType, requestType) &&");
            sourceBuilder.AppendLine("                       IsCompatibleResponseType(m.ResponseType, responseType))");
            sourceBuilder.AppendLine("                .OrderBy(m => m.Order)");
            sourceBuilder.AppendLine("                .Select(m => CreateStreamPipelineBehavior<TRequest, TResponse>(m, serviceProvider))");
            sourceBuilder.AppendLine("                .Where(b => b != null)");
            sourceBuilder.AppendLine("                .Cast<IStreamPipelineBehavior<TRequest, TResponse>>();");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            // Generate helper methods
            GenerateHelperMethods(sourceBuilder, pipelineHandlers);

            // Generate pipeline metadata class
            GeneratePipelineMetadataClass(sourceBuilder);
        }

        private void GenerateHelperMethods(StringBuilder sourceBuilder, List<HandlerInfo> pipelineHandlers)
        {
            sourceBuilder.AppendLine("        private static bool IsCompatibleRequestType(Type pipelineRequestType, Type actualRequestType)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            return pipelineRequestType.IsAssignableFrom(actualRequestType) ||");
            sourceBuilder.AppendLine("                   pipelineRequestType == typeof(object) ||");
            sourceBuilder.AppendLine("                   actualRequestType.IsAssignableFrom(pipelineRequestType);");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            sourceBuilder.AppendLine("        private static bool IsCompatibleResponseType(Type pipelineResponseType, Type actualResponseType)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            return pipelineResponseType.IsAssignableFrom(actualResponseType) ||");
            sourceBuilder.AppendLine("                   pipelineResponseType == typeof(object) ||");
            sourceBuilder.AppendLine("                   actualResponseType.IsAssignableFrom(pipelineResponseType);");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            sourceBuilder.AppendLine("        private static IPipelineBehavior<TRequest, TResponse>? CreatePipelineBehavior<TRequest, TResponse>(PipelineMetadata metadata, IServiceProvider serviceProvider)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            try");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                var instance = serviceProvider.GetService(metadata.ContainingType);");
            sourceBuilder.AppendLine("                if (instance == null) return null;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("                return new GeneratedPipelineBehavior<TRequest, TResponse>(instance, metadata);");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("            catch");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                return null;");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            sourceBuilder.AppendLine("        private static IStreamPipelineBehavior<TRequest, TResponse>? CreateStreamPipelineBehavior<TRequest, TResponse>(PipelineMetadata metadata, IServiceProvider serviceProvider)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            try");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                var instance = serviceProvider.GetService(metadata.ContainingType);");
            sourceBuilder.AppendLine("                if (instance == null) return null;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("                return new GeneratedStreamPipelineBehavior<TRequest, TResponse>(instance, metadata);");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("            catch");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                return null;");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
        }

        private void GeneratePipelineMetadataClass(StringBuilder sourceBuilder)
        {
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Metadata for a pipeline behavior.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        private class PipelineMetadata");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            public Type ContainingType { get; set; } = null!;");
            sourceBuilder.AppendLine("            public string MethodName { get; set; } = null!;");
            sourceBuilder.AppendLine("            public Type RequestType { get; set; } = null!;");
            sourceBuilder.AppendLine("            public Type ResponseType { get; set; } = null!;");
            sourceBuilder.AppendLine("            public int Order { get; set; }");
            sourceBuilder.AppendLine("            public PipelineScope Scope { get; set; }");
            sourceBuilder.AppendLine("            public bool IsStreamPipeline { get; set; }");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            // Generate wrapper classes for pipeline behaviors
            GeneratePipelineWrapperClasses(sourceBuilder);
        }

        private void GeneratePipelineWrapperClasses(StringBuilder sourceBuilder)
        {
            // Generate regular pipeline behavior wrapper
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Generated wrapper for pipeline behaviors.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        private class GeneratedPipelineBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            private readonly object _instance;");
            sourceBuilder.AppendLine("            private readonly PipelineMetadata _metadata;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            public GeneratedPipelineBehavior(object instance, PipelineMetadata metadata)");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                _instance = instance;");
            sourceBuilder.AppendLine("                _metadata = metadata;");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            public ValueTask<TResponse> HandleAsync(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                var method = _metadata.ContainingType.GetMethod(_metadata.MethodName);");
            sourceBuilder.AppendLine("                if (method == null) return next();");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("                try");
            sourceBuilder.AppendLine("                {");
            sourceBuilder.AppendLine("                    var result = method.Invoke(_instance, new object[] { request, next, cancellationToken });");
            sourceBuilder.AppendLine("                    if (result is ValueTask<TResponse> valueTask)");
            sourceBuilder.AppendLine("                        return valueTask;");
            sourceBuilder.AppendLine("                    if (result is Task<TResponse> task)");
            sourceBuilder.AppendLine("                        return new ValueTask<TResponse>(task);");
            sourceBuilder.AppendLine("                    return next();");
            sourceBuilder.AppendLine("                }");
            sourceBuilder.AppendLine("                catch");
            sourceBuilder.AppendLine("                {");
            sourceBuilder.AppendLine("                    return next();");
            sourceBuilder.AppendLine("                }");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            // Generate stream pipeline behavior wrapper
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Generated wrapper for stream pipeline behaviors.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        private class GeneratedStreamPipelineBehavior<TRequest, TResponse> : IStreamPipelineBehavior<TRequest, TResponse>");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            private readonly object _instance;");
            sourceBuilder.AppendLine("            private readonly PipelineMetadata _metadata;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            public GeneratedStreamPipelineBehavior(object instance, PipelineMetadata metadata)");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                _instance = instance;");
            sourceBuilder.AppendLine("                _metadata = metadata;");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            public IAsyncEnumerable<TResponse> HandleAsync(TRequest request, StreamHandlerDelegate<TResponse> next, CancellationToken cancellationToken)");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                var method = _metadata.ContainingType.GetMethod(_metadata.MethodName);");
            sourceBuilder.AppendLine("                if (method == null) return next();");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("                try");
            sourceBuilder.AppendLine("                {");
            sourceBuilder.AppendLine("                    var result = method.Invoke(_instance, new object[] { request, next, cancellationToken });");
            sourceBuilder.AppendLine("                    if (result is IAsyncEnumerable<TResponse> asyncEnumerable)");
            sourceBuilder.AppendLine("                        return asyncEnumerable;");
            sourceBuilder.AppendLine("                    return next();");
            sourceBuilder.AppendLine("                }");
            sourceBuilder.AppendLine("                catch");
            sourceBuilder.AppendLine("                {");
            sourceBuilder.AppendLine("                    return next();");
            sourceBuilder.AppendLine("                }");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("        }");
        }

        private string GetPipelineRequestType(IMethodSymbol method)
        {
            if (method.Parameters.Length > 0)
            {
                return method.Parameters[0].Type.ToDisplayString();
            }
            return "object";
        }

        private string GetPipelineResponseType(IMethodSymbol method)
        {
            var returnType = method.ReturnType.ToDisplayString();

            // Extract response type from ValueTask<T>, Task<T>, or IAsyncEnumerable<T>
            if (returnType.StartsWith("System.Threading.Tasks.ValueTask<") ||
                returnType.StartsWith("System.Threading.Tasks.Task<"))
            {
                var start = returnType.IndexOf('<') + 1;
                var end = returnType.LastIndexOf('>');
                if (start > 0 && end > start)
                {
                    return returnType.Substring(start, end - start);
                }
            }
            else if (returnType.StartsWith("System.Collections.Generic.IAsyncEnumerable<"))
            {
                var start = returnType.IndexOf('<') + 1;
                var end = returnType.LastIndexOf('>');
                if (start > 0 && end > start)
                {
                    return returnType.Substring(start, end - start);
                }
            }

            return "object";
        }

        private bool IsStreamPipeline(IMethodSymbol method)
        {
            var returnType = method.ReturnType.ToDisplayString();
            return returnType.StartsWith("System.Collections.Generic.IAsyncEnumerable");
        }

        private T GetAttributeProperty<T>(AttributeData attributeData, string propertyName, T defaultValue)
        {
            var namedArg = attributeData.NamedArguments
                .FirstOrDefault(arg => arg.Key == propertyName);

            if (namedArg.Value.Value is T value)
            {
                return value;
            }

            return defaultValue;
        }

        private bool TryParsePipelineAttributeFromSyntax(MethodDeclarationSyntax method, out int? order, out string? scope)
        {
            order = null;
            scope = null;
            foreach (var attr in method.AttributeLists.SelectMany(al => al.Attributes))
            {
                var name = attr.Name.ToString();
                if (!name.EndsWith("Pipeline") && !name.EndsWith("PipelineAttribute"))
                    continue;

                if (attr.ArgumentList == null) break;
                foreach (var arg in attr.ArgumentList.Arguments)
                {
                    var propName = arg.NameEquals?.Name.Identifier.ValueText;
                    if (string.Equals(propName, "Order", StringComparison.Ordinal))
                    {
                        if (arg.Expression is LiteralExpressionSyntax les && les.IsKind(SyntaxKind.NumericLiteralExpression))
                        {
                            if (les.Token.Value is int i) order = i;
                        }
                    }
                    else if (string.Equals(propName, "Scope", StringComparison.Ordinal))
                    {
                        if (arg.Expression is MemberAccessExpressionSyntax maes)
                        {
                            scope = maes.Name.Identifier.ValueText;
                        }
                        else if (arg.Expression is IdentifierNameSyntax ins)
                        {
                            scope = ins.Identifier.ValueText;
                        }
                    }
                }
                break;
            }
            return order.HasValue || !string.IsNullOrWhiteSpace(scope);
        }

        /// <inheritdoc/>
        protected override void AppendUsings(StringBuilder builder, HandlerDiscoveryResult result, GenerationOptions options)
        {
            builder.AppendLine("using System;");
            builder.AppendLine("using System.Collections.Generic;");
            builder.AppendLine("using System.Linq;");
            builder.AppendLine("using System.Threading;");
            builder.AppendLine("using System.Threading.Tasks;");
            builder.AppendLine("using Relay.Core;");
        }

        /// <inheritdoc/>
        protected override void GenerateContent(StringBuilder builder, HandlerDiscoveryResult result, GenerationOptions options)
        {
            var pipelineHandlers = result.Handlers
                .Where(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Pipeline))
                .ToList();

            // Generate pipeline registry class
            GeneratePipelineRegistryClass(builder, pipelineHandlers);
        }
    }
}