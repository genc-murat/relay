using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Relay.SourceGenerator
{
    // Local copy to avoid referencing Relay.Core types in the generator assembly
    internal enum NotificationDispatchMode
    {
        Sequential,
        Parallel
    }
    /// <summary>
    /// Generates notification dispatcher implementation code.
    /// </summary>
    public class NotificationDispatcherGenerator
    {
        private readonly RelayCompilationContext _context;

        public NotificationDispatcherGenerator(RelayCompilationContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
        }

        /// <summary>
        /// Generates the notification dispatcher implementation.
        /// </summary>
        public string GenerateNotificationDispatcher(HandlerDiscoveryResult discoveryResult)
        {
            var notificationHandlers = discoveryResult.Handlers
                .Where(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Notification))
                .ToList();

            if (!notificationHandlers.Any())
            {
                return string.Empty; // No notification handlers found
            }

            var sourceBuilder = new StringBuilder();

            // File header
            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("// Generated by Relay.SourceGenerator");
            sourceBuilder.AppendLine($"// Generation time: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
            sourceBuilder.AppendLine();

            // Usings
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine("using System.Collections.Generic;");
            sourceBuilder.AppendLine("using System.Linq;");
            sourceBuilder.AppendLine("using System.Threading;");
            sourceBuilder.AppendLine("using System.Threading.Tasks;");
            sourceBuilder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sourceBuilder.AppendLine("using Microsoft.Extensions.Logging;");
            sourceBuilder.AppendLine("using Relay.Core;");
            sourceBuilder.AppendLine();

            // Namespace
            sourceBuilder.AppendLine("namespace Relay.Generated");
            sourceBuilder.AppendLine("{");

            // Generate the dispatcher class
            GenerateGeneratedNotificationDispatcher(sourceBuilder, notificationHandlers);

            sourceBuilder.AppendLine("}");

            return sourceBuilder.ToString();
        }

        private void GenerateGeneratedNotificationDispatcher(StringBuilder sourceBuilder, List<HandlerInfo> notificationHandlers)
        {
            sourceBuilder.AppendLine("    /// <summary>");
            sourceBuilder.AppendLine("    /// Generated notification dispatcher with compile-time handler registration.");
            sourceBuilder.AppendLine("    /// </summary>");
            sourceBuilder.AppendLine("    public class GeneratedNotificationDispatcher : BaseNotificationDispatcher");
            sourceBuilder.AppendLine("    {");
            sourceBuilder.AppendLine("        private readonly ILogger<GeneratedNotificationDispatcher>? _logger;");
            sourceBuilder.AppendLine();

            // Constructor
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Initializes a new instance of the GeneratedNotificationDispatcher class.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        /// <param name=\"serviceProvider\">The service provider for dependency resolution.</param>");
            sourceBuilder.AppendLine("        public GeneratedNotificationDispatcher(IServiceProvider serviceProvider)");
            sourceBuilder.AppendLine("            : base(serviceProvider)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            _logger = serviceProvider.GetService<ILogger<GeneratedNotificationDispatcher>>();");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            // Main dispatch method
            GenerateDispatchMethod(sourceBuilder, notificationHandlers);

            // Generate specific dispatch methods for each notification type
            GenerateSpecificDispatchMethods(sourceBuilder, notificationHandlers);

            sourceBuilder.AppendLine("    }");
        }

        private void GenerateDispatchMethod(StringBuilder sourceBuilder, List<HandlerInfo> notificationHandlers)
        {
            sourceBuilder.AppendLine("        /// <inheritdoc />");
            sourceBuilder.AppendLine("        public override async ValueTask DispatchAsync<TNotification>(TNotification notification, CancellationToken cancellationToken)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            ValidateRequest(notification, nameof(notification));");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            var notificationType = typeof(TNotification);");
            sourceBuilder.AppendLine("            _logger?.LogDebug(\"Dispatching notification {NotificationType}\", notificationType.Name);");
            sourceBuilder.AppendLine();

            // Generate type-specific dispatch calls
            var notificationTypes = notificationHandlers
                .Select(h => h.MethodSymbol.Parameters[0].Type.ToDisplayString())
                .Distinct()
                .ToList();

            if (notificationTypes.Any())
            {
                sourceBuilder.AppendLine("            // Dispatch to type-specific handlers");
                for (int i = 0; i < notificationTypes.Count; i++)
                {
                    var notificationType = notificationTypes[i];
                    var condition = i == 0 ? "if" : "else if";

                    sourceBuilder.AppendLine($"            {condition} (notificationType == typeof({notificationType}))");
                    sourceBuilder.AppendLine("            {");
                    sourceBuilder.AppendLine($"                await DispatchAsync{GetSafeTypeName(notificationType)}(({notificationType})notification, cancellationToken);");
                    sourceBuilder.AppendLine("            }");
                }

                sourceBuilder.AppendLine("            else");
                sourceBuilder.AppendLine("            {");
                sourceBuilder.AppendLine("                _logger?.LogDebug(\"No handlers registered for notification type {NotificationType}\", notificationType.Name);");
                sourceBuilder.AppendLine("            }");
            }
            else
            {
                sourceBuilder.AppendLine("            _logger?.LogDebug(\"No handlers registered for notification type {NotificationType}\", notificationType.Name);");
            }

            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
        }

        private void GenerateSpecificDispatchMethods(StringBuilder sourceBuilder, List<HandlerInfo> notificationHandlers)
        {
            var handlersByNotificationType = notificationHandlers
                .GroupBy(h => h.MethodSymbol.Parameters[0].Type.ToDisplayString())
                .ToList();

            foreach (var group in handlersByNotificationType)
            {
                var notificationType = group.Key;
                var handlers = group.OrderByDescending(h => GetHandlerPriority(h)).ToList();

                GenerateSpecificDispatchMethod(sourceBuilder, notificationType, handlers);
            }
        }

        private void GenerateSpecificDispatchMethod(StringBuilder sourceBuilder, string notificationType, List<HandlerInfo> handlers)
        {
            var safeTypeName = GetSafeTypeName(notificationType);

            sourceBuilder.AppendLine($"        /// <summary>");
            sourceBuilder.AppendLine($"        /// Dispatches {notificationType} to its registered handlers.");
            sourceBuilder.AppendLine($"        /// </summary>");
            sourceBuilder.AppendLine($"        private async ValueTask DispatchAsync{safeTypeName}({notificationType} notification, CancellationToken cancellationToken)");
            sourceBuilder.AppendLine("        {");

            if (!handlers.Any())
            {
                sourceBuilder.AppendLine("            // No handlers registered");
                sourceBuilder.AppendLine("            await ValueTask.CompletedTask;");
                sourceBuilder.AppendLine("        }");
                sourceBuilder.AppendLine();
                return;
            }

            // Group handlers by dispatch mode
            var parallelHandlers = handlers.Where(h => GetDispatchMode(h) == NotificationDispatchMode.Parallel).ToList();
            var sequentialHandlers = handlers.Where(h => GetDispatchMode(h) == NotificationDispatchMode.Sequential).ToList();

            sourceBuilder.AppendLine($"            _logger?.LogDebug(\"Dispatching {notificationType} to {{HandlerCount}} handlers\", {handlers.Count});");
            sourceBuilder.AppendLine();

            // Execute sequential handlers first
            if (sequentialHandlers.Any())
            {
                sourceBuilder.AppendLine("            // Execute sequential handlers first");
                foreach (var handler in sequentialHandlers)
                {
                    GenerateHandlerExecution(sourceBuilder, handler, "notification", "cancellationToken", isSequential: true);
                }
                sourceBuilder.AppendLine();
            }

            // Execute parallel handlers
            if (parallelHandlers.Any())
            {
                if (parallelHandlers.Count == 1)
                {
                    sourceBuilder.AppendLine("            // Execute single parallel handler");
                    GenerateHandlerExecution(sourceBuilder, parallelHandlers[0], "notification", "cancellationToken", isSequential: true);
                }
                else
                {
                    sourceBuilder.AppendLine("            // Execute parallel handlers concurrently");
                    sourceBuilder.AppendLine("            var parallelTasks = new Task[]");
                    sourceBuilder.AppendLine("            {");

                    foreach (var handler in parallelHandlers)
                    {
                        GenerateHandlerExecutionAsTask(sourceBuilder, handler, "notification", "cancellationToken");
                    }

                    sourceBuilder.AppendLine("            };");
                    sourceBuilder.AppendLine();
                    sourceBuilder.AppendLine("            await Task.WhenAll(parallelTasks);");
                }
            }

            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
        }

        private void GenerateHandlerExecution(StringBuilder sourceBuilder, HandlerInfo handler, string notificationParam, string cancellationTokenParam, bool isSequential)
        {
            var handlerType = handler.MethodSymbol.ContainingType.ToDisplayString();
            var methodName = handler.MethodSymbol.Name;
            var isStatic = handler.MethodSymbol.IsStatic;
            var isAsync = IsAsyncMethod(handler);

            sourceBuilder.AppendLine("            try");
            sourceBuilder.AppendLine("            {");

            if (isStatic)
            {
                if (isAsync)
                {
                    sourceBuilder.AppendLine($"                await {handlerType}.{methodName}({notificationParam}, {cancellationTokenParam});");
                }
                else
                {
                    sourceBuilder.AppendLine($"                {handlerType}.{methodName}({notificationParam}, {cancellationTokenParam});");
                }
            }
            else
            {
                sourceBuilder.AppendLine("                using var scope = CreateScope();");
                sourceBuilder.AppendLine($"                var handler = scope.ServiceProvider.GetRequiredService<{handlerType}>();");

                if (isAsync)
                {
                    sourceBuilder.AppendLine($"                await handler.{methodName}({notificationParam}, {cancellationTokenParam});");
                }
                else
                {
                    sourceBuilder.AppendLine($"                handler.{methodName}({notificationParam}, {cancellationTokenParam});");
                }
            }

            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("            catch (Exception ex)");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine($"                _logger?.LogError(ex, \"Handler {{HandlerType}} failed while processing notification {{NotificationType}}\", \"{handlerType}\", typeof({handler.MethodSymbol.Parameters[0].Type.ToDisplayString()}).Name);");
            sourceBuilder.AppendLine("                // Continue with remaining handlers");
            sourceBuilder.AppendLine("            }");
        }

        private void GenerateHandlerExecutionAsTask(StringBuilder sourceBuilder, HandlerInfo handler, string notificationParam, string cancellationTokenParam)
        {
            var handlerType = handler.MethodSymbol.ContainingType.ToDisplayString();
            var methodName = handler.MethodSymbol.Name;
            var isStatic = handler.MethodSymbol.IsStatic;
            var isAsync = IsAsyncMethod(handler);

            sourceBuilder.AppendLine("                Task.Run(async () =>");
            sourceBuilder.AppendLine("                {");
            sourceBuilder.AppendLine("                    try");
            sourceBuilder.AppendLine("                    {");

            if (isStatic)
            {
                if (isAsync)
                {
                    sourceBuilder.AppendLine($"                        await {handlerType}.{methodName}({notificationParam}, {cancellationTokenParam});");
                }
                else
                {
                    sourceBuilder.AppendLine($"                        {handlerType}.{methodName}({notificationParam}, {cancellationTokenParam});");
                }
            }
            else
            {
                sourceBuilder.AppendLine("                        using var scope = CreateScope();");
                sourceBuilder.AppendLine($"                        var handler = scope.ServiceProvider.GetRequiredService<{handlerType}>();");

                if (isAsync)
                {
                    sourceBuilder.AppendLine($"                        await handler.{methodName}({notificationParam}, {cancellationTokenParam});");
                }
                else
                {
                    sourceBuilder.AppendLine($"                        handler.{methodName}({notificationParam}, {cancellationTokenParam});");
                }
            }

            sourceBuilder.AppendLine("                    }");
            sourceBuilder.AppendLine("                    catch (Exception ex)");
            sourceBuilder.AppendLine("                    {");
            sourceBuilder.AppendLine($"                        _logger?.LogError(ex, \"Handler {{HandlerType}} failed while processing notification {{NotificationType}}\", \"{handlerType}\", typeof({handler.MethodSymbol.Parameters[0].Type.ToDisplayString()}).Name);");
            sourceBuilder.AppendLine("                    }");
            sourceBuilder.AppendLine("                }, cancellationToken),");
        }

        private bool IsAsyncMethod(HandlerInfo handler)
        {
            var returnType = handler.MethodSymbol.ReturnType.ToDisplayString();
            return returnType.Contains("Task") || returnType.Contains("ValueTask");
        }

        private NotificationDispatchMode GetDispatchMode(HandlerInfo handler)
        {
            var notificationAttribute = handler.Attributes.FirstOrDefault(a => a.Type == RelayAttributeType.Notification);
            if (notificationAttribute?.AttributeData != null)
            {
                var dispatchModeArg = notificationAttribute.AttributeData.NamedArguments
                    .FirstOrDefault(arg => arg.Key == "DispatchMode");

                if (dispatchModeArg.Value.Value is int dispatchModeValue)
                {
                    return (NotificationDispatchMode)dispatchModeValue;
                }
            }

            return NotificationDispatchMode.Parallel; // Default
        }

        private int GetHandlerPriority(HandlerInfo handler)
        {
            var notificationAttribute = handler.Attributes.FirstOrDefault(a => a.Type == RelayAttributeType.Notification);
            if (notificationAttribute?.AttributeData != null)
            {
                var priorityArg = notificationAttribute.AttributeData.NamedArguments
                    .FirstOrDefault(arg => arg.Key == "Priority");

                if (priorityArg.Value.Value is int priority)
                {
                    return priority;
                }
            }

            return 0;
        }

        private string GetSafeTypeName(string typeName)
        {
            // Convert type name to a safe method name
            return typeName
                .Replace(".", "_")
                .Replace("<", "_")
                .Replace(">", "_")
                .Replace(",", "_")
                .Replace(" ", "")
                .Replace("[", "_")
                .Replace("]", "_");
        }
    }
}