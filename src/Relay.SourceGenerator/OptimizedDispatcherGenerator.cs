using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Relay.SourceGenerator;

/// <summary>
/// Generates optimized dispatch methods for maximum performance
/// </summary>
public class OptimizedDispatcherGenerator
{
    private readonly RelayCompilationContext _context;

    public OptimizedDispatcherGenerator(RelayCompilationContext context)
    {
        _context = context ?? throw new ArgumentNullException(nameof(context));
    }

    /// <summary>
    /// Generates optimized dispatcher source code with specialized methods for each request type
    /// </summary>
    public string GenerateOptimizedDispatcher(HandlerDiscoveryResult discoveryResult)
    {
        var sourceBuilder = new StringBuilder();
        
        // File header
        sourceBuilder.AppendLine("// <auto-generated />");
        sourceBuilder.AppendLine("// Generated by Relay.SourceGenerator - Optimized Dispatcher");
        sourceBuilder.AppendLine($"// Generation time: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        sourceBuilder.AppendLine();
        
        // Usings
        sourceBuilder.AppendLine("using System;");
        sourceBuilder.AppendLine("using System.Collections.Generic;");
        sourceBuilder.AppendLine("using System.Runtime.CompilerServices;");
        sourceBuilder.AppendLine("using System.Threading;");
        sourceBuilder.AppendLine("using System.Threading.Tasks;");
        sourceBuilder.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sourceBuilder.AppendLine("using Relay.Core;");
        sourceBuilder.AppendLine();
        
        // Namespace
        sourceBuilder.AppendLine("namespace Relay.Generated");
        sourceBuilder.AppendLine("{");
        
        // Generate optimized dispatcher class
        GenerateOptimizedDispatcherClass(sourceBuilder, discoveryResult);
        
        sourceBuilder.AppendLine("}");
        
        return sourceBuilder.ToString();
    }

    private void GenerateOptimizedDispatcherClass(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
    {
        sourceBuilder.AppendLine("    /// <summary>");
        sourceBuilder.AppendLine("    /// High-performance dispatcher with specialized methods for each request type");
        sourceBuilder.AppendLine("    /// </summary>");
        sourceBuilder.AppendLine("    public static class OptimizedDispatcher");
        sourceBuilder.AppendLine("    {");
        
        // Generate type-specific dispatch methods
        GenerateTypeSpecificDispatchMethods(sourceBuilder, discoveryResult);
        
        // Generate main dispatch method with branch prediction optimization
        GenerateMainDispatchMethod(sourceBuilder, discoveryResult);
        
        // Generate streaming dispatch methods
        GenerateStreamingDispatchMethods(sourceBuilder, discoveryResult);
        
        // Generate notification dispatch methods
        GenerateNotificationDispatchMethods(sourceBuilder, discoveryResult);
        
        sourceBuilder.AppendLine("    }");
    }

    private void GenerateTypeSpecificDispatchMethods(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
    {
        var requestHandlers = discoveryResult.Handlers
            .Where(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Handle))
            .GroupBy(h => h.MethodSymbol.Parameters[0].Type.ToDisplayString())
            .ToList();

        foreach (var group in requestHandlers)
        {
            var requestType = group.Key;
            var handlers = group.ToList();
            
            // Generate specialized dispatch method for this request type
            GenerateSpecializedDispatchMethod(sourceBuilder, requestType, handlers);
        }
    }

    private void GenerateSpecializedDispatchMethod(StringBuilder sourceBuilder, string requestType, List<HandlerInfo> handlers)
    {
        var responseType = GetResponseType(handlers.First());
        var methodName = $"Dispatch_{SanitizeTypeName(requestType)}";
        
        sourceBuilder.AppendLine($"        /// <summary>");
        sourceBuilder.AppendLine($"        /// Specialized dispatch method for {requestType}");
        sourceBuilder.AppendLine($"        /// </summary>");
        sourceBuilder.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        
        if (responseType == "void")
        {
            sourceBuilder.AppendLine($"        public static async ValueTask {methodName}(");
        }
        else
        {
            sourceBuilder.AppendLine($"        public static async ValueTask<{responseType}> {methodName}(");
        }
        
        sourceBuilder.AppendLine($"            {requestType} request,");
        sourceBuilder.AppendLine($"            IServiceProvider serviceProvider,");
        sourceBuilder.AppendLine($"            string? handlerName = null,");
        sourceBuilder.AppendLine($"            CancellationToken cancellationToken = default)");
        sourceBuilder.AppendLine($"        {{");
        
        // Generate optimized handler selection with branch prediction
        if (handlers.Count == 1)
        {
            // Single handler - direct invocation
            GenerateSingleHandlerInvocation(sourceBuilder, handlers.First(), responseType);
        }
        else
        {
            // Multiple handlers - optimized selection
            GenerateMultipleHandlerSelection(sourceBuilder, handlers, responseType);
        }
        
        sourceBuilder.AppendLine($"        }}");
        sourceBuilder.AppendLine();
    }

    private void GenerateSingleHandlerInvocation(StringBuilder sourceBuilder, HandlerInfo handler, string responseType)
    {
        var handlerType = handler.MethodSymbol.ContainingType.ToDisplayString();
        var methodName = handler.MethodSymbol.Name;
        var isStatic = handler.MethodSymbol.IsStatic;
        
        sourceBuilder.AppendLine($"            // Direct invocation for single handler - maximum performance");
        
        if (isStatic)
        {
            if (responseType == "void")
            {
                sourceBuilder.AppendLine($"            await {handlerType}.{methodName}(request, cancellationToken);");
            }
            else
            {
                sourceBuilder.AppendLine($"            return await {handlerType}.{methodName}(request, cancellationToken);");
            }
        }
        else
        {
            sourceBuilder.AppendLine($"            var handler = serviceProvider.GetRequiredService<{handlerType}>();");
            if (responseType == "void")
            {
                sourceBuilder.AppendLine($"            await handler.{methodName}(request, cancellationToken);");
            }
            else
            {
                sourceBuilder.AppendLine($"            return await handler.{methodName}(request, cancellationToken);");
            }
        }
    }

    private void GenerateMultipleHandlerSelection(StringBuilder sourceBuilder, List<HandlerInfo> handlers, string responseType)
    {
        sourceBuilder.AppendLine($"            // Optimized handler selection with branch prediction");
        sourceBuilder.AppendLine($"            // Most common handlers first for better branch prediction");
        
        // Sort handlers by priority and put default handler first (most common case)
        var sortedHandlers = handlers
            .OrderByDescending(h => GetHandlerPriority(h))
            .ThenBy(h => GetHandlerName(h) == "default" ? 0 : 1)
            .ToList();
        
        bool isFirst = true;
        foreach (var handler in sortedHandlers)
        {
            var handlerName = GetHandlerName(handler);
            var handlerType = handler.MethodSymbol.ContainingType.ToDisplayString();
            var methodName = handler.MethodSymbol.Name;
            var isStatic = handler.MethodSymbol.IsStatic;
            
            var condition = handlerName == "default" 
                ? "handlerName == null || handlerName == \"default\""
                : $"handlerName == \"{handlerName}\"";
            
            var keyword = isFirst ? "if" : "else if";
            sourceBuilder.AppendLine($"            {keyword} ({condition})");
            sourceBuilder.AppendLine($"            {{");
            
            if (isStatic)
            {
                if (responseType == "void")
                {
                    sourceBuilder.AppendLine($"                await {handlerType}.{methodName}(request, cancellationToken);");
                    sourceBuilder.AppendLine($"                return;");
                }
                else
                {
                    sourceBuilder.AppendLine($"                return await {handlerType}.{methodName}(request, cancellationToken);");
                }
            }
            else
            {
                sourceBuilder.AppendLine($"                var handler = serviceProvider.GetRequiredService<{handlerType}>();");
                if (responseType == "void")
                {
                    sourceBuilder.AppendLine($"                await handler.{methodName}(request, cancellationToken);");
                    sourceBuilder.AppendLine($"                return;");
                }
                else
                {
                    sourceBuilder.AppendLine($"                return await handler.{methodName}(request, cancellationToken);");
                }
            }
            
            sourceBuilder.AppendLine($"            }}");
            isFirst = false;
        }
        
        // Generate fallback for unknown handler names
        var requestTypeName = handlers.FirstOrDefault()?.MethodSymbol?.Parameters.FirstOrDefault()?.Type?.ToDisplayString() ?? "Unknown";
        sourceBuilder.AppendLine($"            else");
        sourceBuilder.AppendLine($"            {{");
        sourceBuilder.AppendLine($"                throw new InvalidOperationException($\"No handler found with name '{{handlerName}}' for request type '{requestTypeName.Replace("\"", "\\\"")}'.\");");
        sourceBuilder.AppendLine($"            }}");
    }

    private void GenerateMainDispatchMethod(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
    {
        sourceBuilder.AppendLine($"        /// <summary>");
        sourceBuilder.AppendLine($"        /// Main dispatch method with optimized type switching");
        sourceBuilder.AppendLine($"        /// </summary>");
        sourceBuilder.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sourceBuilder.AppendLine($"        public static async ValueTask<TResponse> DispatchAsync<TRequest, TResponse>(");
        sourceBuilder.AppendLine($"            TRequest request,");
        sourceBuilder.AppendLine($"            IServiceProvider serviceProvider,");
        sourceBuilder.AppendLine($"            string? handlerName = null,");
        sourceBuilder.AppendLine($"            CancellationToken cancellationToken = default)");
        sourceBuilder.AppendLine($"            where TRequest : IRequest<TResponse>");
        sourceBuilder.AppendLine($"        {{");
        
        // Generate type-specific dispatch calls with branch prediction optimization
        var requestTypes = discoveryResult.Handlers
            .Where(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Handle))
            .Select(h => h.MethodSymbol.Parameters[0].Type.ToDisplayString())
            .Distinct()
            .OrderBy(t => t) // Consistent ordering for better branch prediction
            .ToList();
        
        sourceBuilder.AppendLine($"            // Optimized type switching - most common types first");
        sourceBuilder.AppendLine($"            var requestType = typeof(TRequest);");
        sourceBuilder.AppendLine();
        
        bool isFirst = true;
        foreach (var requestType in requestTypes)
        {
            var methodName = $"Dispatch_{SanitizeTypeName(requestType)}";
            var keyword = isFirst ? "if" : "else if";
            
            sourceBuilder.AppendLine($"            {keyword} (requestType == typeof({requestType}))");
            sourceBuilder.AppendLine($"            {{");
            sourceBuilder.AppendLine($"                var result = await {methodName}(({requestType})(object)request, serviceProvider, handlerName, cancellationToken);");
            sourceBuilder.AppendLine($"                return (TResponse)(object)result!;");
            sourceBuilder.AppendLine($"            }}");
            
            isFirst = false;
        }
        
        sourceBuilder.AppendLine($"            else");
        sourceBuilder.AppendLine($"            {{");
        sourceBuilder.AppendLine($"                throw new InvalidOperationException($\"No handler found for request type '{{requestType.Name}}'.\");");
        sourceBuilder.AppendLine($"            }}");
        sourceBuilder.AppendLine($"        }}");
        sourceBuilder.AppendLine();
    }

    private void GenerateStreamingDispatchMethods(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
    {
        var streamHandlers = discoveryResult.Handlers
            .Where(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Handle) && 
                       h.MethodSymbol.ReturnType.ToDisplayString().Contains("IAsyncEnumerable"))
            .ToList();

        if (!streamHandlers.Any()) return;

        sourceBuilder.AppendLine($"        /// <summary>");
        sourceBuilder.AppendLine($"        /// Optimized streaming dispatch method");
        sourceBuilder.AppendLine($"        /// </summary>");
        sourceBuilder.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sourceBuilder.AppendLine($"        public static IAsyncEnumerable<TResponse> DispatchStreamAsync<TRequest, TResponse>(");
        sourceBuilder.AppendLine($"            TRequest request,");
        sourceBuilder.AppendLine($"            IServiceProvider serviceProvider,");
        sourceBuilder.AppendLine($"            string? handlerName = null,");
        sourceBuilder.AppendLine($"            CancellationToken cancellationToken = default)");
        sourceBuilder.AppendLine($"            where TRequest : IStreamRequest<TResponse>");
        sourceBuilder.AppendLine($"        {{");
        
        // Generate streaming dispatch logic
        sourceBuilder.AppendLine($"            var requestType = typeof(TRequest);");
        sourceBuilder.AppendLine();
        
        bool isFirst = true;
        foreach (var handler in streamHandlers)
        {
            var requestType = handler.MethodSymbol.Parameters[0].Type.ToDisplayString();
            var handlerType = handler.MethodSymbol.ContainingType.ToDisplayString();
            var methodName = handler.MethodSymbol.Name;
            var isStatic = handler.MethodSymbol.IsStatic;
            var keyword = isFirst ? "if" : "else if";
            
            sourceBuilder.AppendLine($"            {keyword} (requestType == typeof({requestType}))");
            sourceBuilder.AppendLine($"            {{");
            
            if (isStatic)
            {
                sourceBuilder.AppendLine($"                return {handlerType}.{methodName}(({requestType})(object)request, cancellationToken).Cast<TResponse>();");
            }
            else
            {
                sourceBuilder.AppendLine($"                var handler = serviceProvider.GetRequiredService<{handlerType}>();");
                sourceBuilder.AppendLine($"                return handler.{methodName}(({requestType})(object)request, cancellationToken).Cast<TResponse>();");
            }
            
            sourceBuilder.AppendLine($"            }}");
            isFirst = false;
        }
        
        sourceBuilder.AppendLine($"            else");
        sourceBuilder.AppendLine($"            {{");
        sourceBuilder.AppendLine($"                throw new InvalidOperationException($\"No streaming handler found for request type '{{requestType.Name}}'.\");");
        sourceBuilder.AppendLine($"            }}");
        sourceBuilder.AppendLine($"        }}");
        sourceBuilder.AppendLine();
    }

    private void GenerateNotificationDispatchMethods(StringBuilder sourceBuilder, HandlerDiscoveryResult discoveryResult)
    {
        var notificationHandlers = discoveryResult.Handlers
            .Where(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Notification))
            .ToList();

        if (!notificationHandlers.Any()) return;

        sourceBuilder.AppendLine($"        /// <summary>");
        sourceBuilder.AppendLine($"        /// Optimized notification dispatch method");
        sourceBuilder.AppendLine($"        /// </summary>");
        sourceBuilder.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sourceBuilder.AppendLine($"        public static async ValueTask DispatchNotificationAsync<TNotification>(");
        sourceBuilder.AppendLine($"            TNotification notification,");
        sourceBuilder.AppendLine($"            IServiceProvider serviceProvider,");
        sourceBuilder.AppendLine($"            CancellationToken cancellationToken = default)");
        sourceBuilder.AppendLine($"            where TNotification : INotification");
        sourceBuilder.AppendLine($"        {{");
        
        // Group notification handlers by type
        var notificationGroups = notificationHandlers
            .GroupBy(h => h.MethodSymbol.Parameters[0].Type.ToDisplayString())
            .ToList();
        
        sourceBuilder.AppendLine($"            var notificationType = typeof(TNotification);");
        sourceBuilder.AppendLine();
        
        bool isFirst = true;
        foreach (var group in notificationGroups)
        {
            var notificationType = group.Key;
            var handlers = group.ToList();
            var keyword = isFirst ? "if" : "else if";
            
            sourceBuilder.AppendLine($"            {keyword} (notificationType == typeof({notificationType}))");
            sourceBuilder.AppendLine($"            {{");
            sourceBuilder.AppendLine($"                var tasks = new List<ValueTask>();");
            
            foreach (var handler in handlers)
            {
                var handlerType = handler.MethodSymbol.ContainingType.ToDisplayString();
                var methodName = handler.MethodSymbol.Name;
                var isStatic = handler.MethodSymbol.IsStatic;
                
                if (isStatic)
                {
                    sourceBuilder.AppendLine($"                tasks.Add({handlerType}.{methodName}(({notificationType})(object)notification, cancellationToken));");
                }
                else
                {
                    sourceBuilder.AppendLine($"                {{");
                    sourceBuilder.AppendLine($"                    var handler = serviceProvider.GetRequiredService<{handlerType}>();");
                    sourceBuilder.AppendLine($"                    tasks.Add(handler.{methodName}(({notificationType})(object)notification, cancellationToken));");
                    sourceBuilder.AppendLine($"                }}");
                }
            }
            
            sourceBuilder.AppendLine($"                await ValueTask.WhenAll(tasks.ToArray());");
            sourceBuilder.AppendLine($"                return;");
            sourceBuilder.AppendLine($"            }}");
            
            isFirst = false;
        }
        
        sourceBuilder.AppendLine($"            // No handlers found - this is valid for notifications");
        sourceBuilder.AppendLine($"        }}");
        sourceBuilder.AppendLine();
    }

    private string GetResponseType(HandlerInfo handler)
    {
        var returnType = handler.MethodSymbol.ReturnType;
        var returnTypeString = returnType.ToDisplayString();
        
        // Handle ValueTask<T>, Task<T>
        if (returnTypeString.StartsWith("System.Threading.Tasks.ValueTask<") ||
            returnTypeString.StartsWith("System.Threading.Tasks.Task<"))
        {
            var genericArgs = ((INamedTypeSymbol)returnType).TypeArguments;
            if (genericArgs.Length > 0)
            {
                return genericArgs[0].ToDisplayString();
            }
        }
        else if (returnTypeString.StartsWith("System.Collections.Generic.IAsyncEnumerable<"))
        {
            // Stream handler
            var genericArgs = ((INamedTypeSymbol)returnType).TypeArguments;
            if (genericArgs.Length > 0)
            {
                return genericArgs[0].ToDisplayString();
            }
        }
        else if (!returnTypeString.Contains("Task") && returnType.SpecialType != SpecialType.System_Void)
        {
            // Direct return type
            return returnTypeString;
        }
        
        return "void";
    }

    private string GetHandlerName(HandlerInfo handler)
    {
        var handleAttribute = handler.Attributes.FirstOrDefault(a => a.Type == RelayAttributeType.Handle);
        if (handleAttribute?.AttributeData != null)
        {
            var nameArg = handleAttribute.AttributeData.NamedArguments
                .FirstOrDefault(arg => arg.Key == "Name");
            
            if (nameArg.Value.Value is string name && !string.IsNullOrEmpty(name))
            {
                return name;
            }
        }
        
        return "default";
    }

    private int GetHandlerPriority(HandlerInfo handler)
    {
        foreach (var attribute in handler.Attributes)
        {
            if (attribute.AttributeData != null)
            {
                var priorityArg = attribute.AttributeData.NamedArguments
                    .FirstOrDefault(arg => arg.Key == "Priority");
                
                if (priorityArg.Value.Value is int priority)
                {
                    return priority;
                }
            }
        }
        
        return 0;
    }

    private string SanitizeTypeName(string typeName)
    {
        return typeName
            .Replace(".", "_")
            .Replace("<", "_")
            .Replace(">", "_")
            .Replace(",", "_")
            .Replace(" ", "")
            .Replace("[", "_")
            .Replace("]", "_");
    }
}