using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Relay.SourceGenerator
{
    /// <summary>
    /// Generates pipeline registration code for discovered pipeline behaviors.
    /// </summary>
    public class PipelineRegistryGenerator
    {
        private readonly RelayCompilationContext _context;

        public PipelineRegistryGenerator(RelayCompilationContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
        }

        /// <summary>
        /// Generates the pipeline registry source code.
        /// </summary>
        public string GeneratePipelineRegistry(HandlerDiscoveryResult discoveryResult)
        {
            var pipelineHandlers = discoveryResult.Handlers
                .Where(h => h.Attributes.Any(a => a.Type == RelayAttributeType.Pipeline))
                .ToList();

            if (!pipelineHandlers.Any())
            {
                return string.Empty;
            }

            var sourceBuilder = new StringBuilder();
            
            // File header
            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("// Generated by Relay.SourceGenerator");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine("using System.Collections.Generic;");
            sourceBuilder.AppendLine("using System.Linq;");
            sourceBuilder.AppendLine("using System.Threading;");
            sourceBuilder.AppendLine("using System.Threading.Tasks;");
            sourceBuilder.AppendLine("using Relay.Core;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("namespace Relay.Generated");
            sourceBuilder.AppendLine("{");

            // Generate pipeline registry class
            GeneratePipelineRegistryClass(sourceBuilder, pipelineHandlers);

            sourceBuilder.AppendLine("}");

            return sourceBuilder.ToString();
        }

        private void GeneratePipelineRegistryClass(StringBuilder sourceBuilder, List<HandlerInfo> pipelineHandlers)
        {
            sourceBuilder.AppendLine("    /// <summary>");
            sourceBuilder.AppendLine("    /// Generated pipeline registry for managing pipeline behaviors.");
            sourceBuilder.AppendLine("    /// </summary>");
            sourceBuilder.AppendLine("    internal static class PipelineRegistry");
            sourceBuilder.AppendLine("    {");

            // Generate pipeline metadata
            GeneratePipelineMetadata(sourceBuilder, pipelineHandlers);

            // Generate pipeline discovery methods
            GeneratePipelineDiscoveryMethods(sourceBuilder, pipelineHandlers);

            sourceBuilder.AppendLine("    }");
        }

        private void GeneratePipelineMetadata(StringBuilder sourceBuilder, List<HandlerInfo> pipelineHandlers)
        {
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Pipeline behavior metadata.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        private static readonly PipelineMetadata[] _pipelineMetadata = new[]");
            sourceBuilder.AppendLine("        {");

            foreach (var handler in pipelineHandlers)
            {
                var pipelineAttribute = handler.Attributes.First(a => a.Type == RelayAttributeType.Pipeline);
                var order = GetAttributeProperty(pipelineAttribute.AttributeData, "Order", 0);
                var scope = GetAttributeProperty(pipelineAttribute.AttributeData, "Scope", "All");
                
                var containingType = handler.MethodSymbol.ContainingType.ToDisplayString();
                var methodName = handler.MethodSymbol.Name;
                var requestType = GetPipelineRequestType(handler.MethodSymbol);
                var responseType = GetPipelineResponseType(handler.MethodSymbol);
                var isStreamPipeline = IsStreamPipeline(handler.MethodSymbol);

                sourceBuilder.AppendLine($"            new PipelineMetadata");
                sourceBuilder.AppendLine("            {");
                sourceBuilder.AppendLine($"                ContainingType = typeof({containingType}),");
                sourceBuilder.AppendLine($"                MethodName = \"{methodName}\",");
                sourceBuilder.AppendLine($"                RequestType = typeof({requestType}),");
                sourceBuilder.AppendLine($"                ResponseType = typeof({responseType}),");
                sourceBuilder.AppendLine($"                Order = {order},");
                sourceBuilder.AppendLine($"                Scope = PipelineScope.{scope},");
                sourceBuilder.AppendLine($"                IsStreamPipeline = {isStreamPipeline.ToString().ToLowerInvariant()}");
                sourceBuilder.AppendLine("            },");
            }

            sourceBuilder.AppendLine("        };");
            sourceBuilder.AppendLine();
        }

        private void GeneratePipelineDiscoveryMethods(StringBuilder sourceBuilder, List<HandlerInfo> pipelineHandlers)
        {
            // Generate method to get pipeline behaviors for request types
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Gets pipeline behaviors for the specified request type.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        public static IEnumerable<IPipelineBehavior<TRequest, TResponse>> GetPipelineBehaviors<TRequest, TResponse>(IServiceProvider serviceProvider)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            var requestType = typeof(TRequest);");
            sourceBuilder.AppendLine("            var responseType = typeof(TResponse);");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            return _pipelineMetadata");
            sourceBuilder.AppendLine("                .Where(m => !m.IsStreamPipeline && ");
            sourceBuilder.AppendLine("                       (m.Scope == PipelineScope.All || m.Scope == PipelineScope.Requests) &&");
            sourceBuilder.AppendLine("                       IsCompatibleRequestType(m.RequestType, requestType) &&");
            sourceBuilder.AppendLine("                       IsCompatibleResponseType(m.ResponseType, responseType))");
            sourceBuilder.AppendLine("                .OrderBy(m => m.Order)");
            sourceBuilder.AppendLine("                .Select(m => CreatePipelineBehavior<TRequest, TResponse>(m, serviceProvider))");
            sourceBuilder.AppendLine("                .Where(b => b != null)");
            sourceBuilder.AppendLine("                .Cast<IPipelineBehavior<TRequest, TResponse>>();");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            // Generate method to get stream pipeline behaviors
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Gets stream pipeline behaviors for the specified request type.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        public static IEnumerable<IStreamPipelineBehavior<TRequest, TResponse>> GetStreamPipelineBehaviors<TRequest, TResponse>(IServiceProvider serviceProvider)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            var requestType = typeof(TRequest);");
            sourceBuilder.AppendLine("            var responseType = typeof(TResponse);");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            return _pipelineMetadata");
            sourceBuilder.AppendLine("                .Where(m => m.IsStreamPipeline && ");
            sourceBuilder.AppendLine("                       (m.Scope == PipelineScope.All || m.Scope == PipelineScope.Streams) &&");
            sourceBuilder.AppendLine("                       IsCompatibleRequestType(m.RequestType, requestType) &&");
            sourceBuilder.AppendLine("                       IsCompatibleResponseType(m.ResponseType, responseType))");
            sourceBuilder.AppendLine("                .OrderBy(m => m.Order)");
            sourceBuilder.AppendLine("                .Select(m => CreateStreamPipelineBehavior<TRequest, TResponse>(m, serviceProvider))");
            sourceBuilder.AppendLine("                .Where(b => b != null)");
            sourceBuilder.AppendLine("                .Cast<IStreamPipelineBehavior<TRequest, TResponse>>();");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            // Generate helper methods
            GenerateHelperMethods(sourceBuilder, pipelineHandlers);

            // Generate pipeline metadata class
            GeneratePipelineMetadataClass(sourceBuilder);
        }

        private void GenerateHelperMethods(StringBuilder sourceBuilder, List<HandlerInfo> pipelineHandlers)
        {
            sourceBuilder.AppendLine("        private static bool IsCompatibleRequestType(Type pipelineRequestType, Type actualRequestType)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            return pipelineRequestType.IsAssignableFrom(actualRequestType) ||");
            sourceBuilder.AppendLine("                   pipelineRequestType == typeof(object) ||");
            sourceBuilder.AppendLine("                   actualRequestType.IsAssignableFrom(pipelineRequestType);");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            sourceBuilder.AppendLine("        private static bool IsCompatibleResponseType(Type pipelineResponseType, Type actualResponseType)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            return pipelineResponseType.IsAssignableFrom(actualResponseType) ||");
            sourceBuilder.AppendLine("                   pipelineResponseType == typeof(object) ||");
            sourceBuilder.AppendLine("                   actualResponseType.IsAssignableFrom(pipelineResponseType);");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            sourceBuilder.AppendLine("        private static IPipelineBehavior<TRequest, TResponse>? CreatePipelineBehavior<TRequest, TResponse>(PipelineMetadata metadata, IServiceProvider serviceProvider)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            try");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                var instance = serviceProvider.GetService(metadata.ContainingType);");
            sourceBuilder.AppendLine("                if (instance == null) return null;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("                return new GeneratedPipelineBehavior<TRequest, TResponse>(instance, metadata);");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("            catch");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                return null;");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            sourceBuilder.AppendLine("        private static IStreamPipelineBehavior<TRequest, TResponse>? CreateStreamPipelineBehavior<TRequest, TResponse>(PipelineMetadata metadata, IServiceProvider serviceProvider)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            try");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                var instance = serviceProvider.GetService(metadata.ContainingType);");
            sourceBuilder.AppendLine("                if (instance == null) return null;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("                return new GeneratedStreamPipelineBehavior<TRequest, TResponse>(instance, metadata);");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("            catch");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                return null;");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
        }

        private void GeneratePipelineMetadataClass(StringBuilder sourceBuilder)
        {
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Metadata for a pipeline behavior.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        private class PipelineMetadata");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            public Type ContainingType { get; set; } = null!;");
            sourceBuilder.AppendLine("            public string MethodName { get; set; } = null!;");
            sourceBuilder.AppendLine("            public Type RequestType { get; set; } = null!;");
            sourceBuilder.AppendLine("            public Type ResponseType { get; set; } = null!;");
            sourceBuilder.AppendLine("            public int Order { get; set; }");
            sourceBuilder.AppendLine("            public PipelineScope Scope { get; set; }");
            sourceBuilder.AppendLine("            public bool IsStreamPipeline { get; set; }");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            // Generate wrapper classes for pipeline behaviors
            GeneratePipelineWrapperClasses(sourceBuilder);
        }

        private void GeneratePipelineWrapperClasses(StringBuilder sourceBuilder)
        {
            // Generate regular pipeline behavior wrapper
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Generated wrapper for pipeline behaviors.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        private class GeneratedPipelineBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            private readonly object _instance;");
            sourceBuilder.AppendLine("            private readonly PipelineMetadata _metadata;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            public GeneratedPipelineBehavior(object instance, PipelineMetadata metadata)");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                _instance = instance;");
            sourceBuilder.AppendLine("                _metadata = metadata;");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            public ValueTask<TResponse> HandleAsync(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                var method = _metadata.ContainingType.GetMethod(_metadata.MethodName);");
            sourceBuilder.AppendLine("                if (method == null) return next();");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("                try");
            sourceBuilder.AppendLine("                {");
            sourceBuilder.AppendLine("                    var result = method.Invoke(_instance, new object[] { request, next, cancellationToken });");
            sourceBuilder.AppendLine("                    if (result is ValueTask<TResponse> valueTask)");
            sourceBuilder.AppendLine("                        return valueTask;");
            sourceBuilder.AppendLine("                    if (result is Task<TResponse> task)");
            sourceBuilder.AppendLine("                        return new ValueTask<TResponse>(task);");
            sourceBuilder.AppendLine("                    return next();");
            sourceBuilder.AppendLine("                }");
            sourceBuilder.AppendLine("                catch");
            sourceBuilder.AppendLine("                {");
            sourceBuilder.AppendLine("                    return next();");
            sourceBuilder.AppendLine("                }");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();

            // Generate stream pipeline behavior wrapper
            sourceBuilder.AppendLine("        /// <summary>");
            sourceBuilder.AppendLine("        /// Generated wrapper for stream pipeline behaviors.");
            sourceBuilder.AppendLine("        /// </summary>");
            sourceBuilder.AppendLine("        private class GeneratedStreamPipelineBehavior<TRequest, TResponse> : IStreamPipelineBehavior<TRequest, TResponse>");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            private readonly object _instance;");
            sourceBuilder.AppendLine("            private readonly PipelineMetadata _metadata;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            public GeneratedStreamPipelineBehavior(object instance, PipelineMetadata metadata)");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                _instance = instance;");
            sourceBuilder.AppendLine("                _metadata = metadata;");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("            public IAsyncEnumerable<TResponse> HandleAsync(TRequest request, StreamHandlerDelegate<TResponse> next, CancellationToken cancellationToken)");
            sourceBuilder.AppendLine("            {");
            sourceBuilder.AppendLine("                var method = _metadata.ContainingType.GetMethod(_metadata.MethodName);");
            sourceBuilder.AppendLine("                if (method == null) return next();");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("                try");
            sourceBuilder.AppendLine("                {");
            sourceBuilder.AppendLine("                    var result = method.Invoke(_instance, new object[] { request, next, cancellationToken });");
            sourceBuilder.AppendLine("                    if (result is IAsyncEnumerable<TResponse> asyncEnumerable)");
            sourceBuilder.AppendLine("                        return asyncEnumerable;");
            sourceBuilder.AppendLine("                    return next();");
            sourceBuilder.AppendLine("                }");
            sourceBuilder.AppendLine("                catch");
            sourceBuilder.AppendLine("                {");
            sourceBuilder.AppendLine("                    return next();");
            sourceBuilder.AppendLine("                }");
            sourceBuilder.AppendLine("            }");
            sourceBuilder.AppendLine("        }");
        }

        private string GetPipelineRequestType(IMethodSymbol method)
        {
            if (method.Parameters.Length > 0)
            {
                return method.Parameters[0].Type.ToDisplayString();
            }
            return "object";
        }

        private string GetPipelineResponseType(IMethodSymbol method)
        {
            var returnType = method.ReturnType.ToDisplayString();
            
            // Extract response type from ValueTask<T>, Task<T>, or IAsyncEnumerable<T>
            if (returnType.StartsWith("System.Threading.Tasks.ValueTask<") ||
                returnType.StartsWith("System.Threading.Tasks.Task<"))
            {
                var start = returnType.IndexOf('<') + 1;
                var end = returnType.LastIndexOf('>');
                if (start > 0 && end > start)
                {
                    return returnType.Substring(start, end - start);
                }
            }
            else if (returnType.StartsWith("System.Collections.Generic.IAsyncEnumerable<"))
            {
                var start = returnType.IndexOf('<') + 1;
                var end = returnType.LastIndexOf('>');
                if (start > 0 && end > start)
                {
                    return returnType.Substring(start, end - start);
                }
            }
            
            return "object";
        }

        private bool IsStreamPipeline(IMethodSymbol method)
        {
            var returnType = method.ReturnType.ToDisplayString();
            return returnType.StartsWith("System.Collections.Generic.IAsyncEnumerable");
        }

        private T GetAttributeProperty<T>(AttributeData attributeData, string propertyName, T defaultValue)
        {
            var namedArg = attributeData.NamedArguments
                .FirstOrDefault(arg => arg.Key == propertyName);
            
            if (namedArg.Value.Value is T value)
            {
                return value;
            }
            
            return defaultValue;
        }
    }
}