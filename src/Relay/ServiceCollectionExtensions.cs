using Microsoft.Extensions.DependencyInjection;
using Relay.Core;
using Relay.Core.Configuration.Options;
using Relay.Core.Contracts.Core;
using Relay.Core.Contracts.Dispatchers;
using Relay.Core.Contracts.Infrastructure;
using Relay.Core.Implementation.Core;
using Relay.Core.Implementation.Dispatchers;
using Relay.Core.Implementation.Fallback;
using Relay.Core.Extensions;
using System;

namespace Relay
{
    /// <summary>
    /// Extension methods for configuring the Relay framework.
    /// </summary>
    public static class ServiceCollectionExtensions
    {
        /// <summary>
        /// Adds Relay configuration services to the service collection.
        /// Note: The main AddRelay method is now generated by the source generator.
        /// </summary>
        /// <param name="services">The service collection to add services to.</param>
        /// <returns>The service collection for chaining.</returns>
        public static IServiceCollection AddRelayConfiguration(this IServiceCollection services)
        {
            return services.RegisterCoreServices(svc =>
            {
                // Add core Relay configuration (NOT calling AddRelayConfiguration recursively!)
                ServiceRegistrationHelper.ConfigureOptionsWithDefault<RelayOptions>(svc);
                ServiceRegistrationHelper.TryAddTransient<IRelay, RelayImplementation>(svc);

                // Register default dispatchers (will be replaced by generated ones if available)
                ServiceRegistrationHelper.TryAddTransient<IRequestDispatcher, FallbackRequestDispatcher>(svc);
                ServiceRegistrationHelper.TryAddTransient<IStreamDispatcher, StreamDispatcher>(svc);
                ServiceRegistrationHelper.TryAddTransient<INotificationDispatcher, NotificationDispatcher>(svc);

                // Register ServiceFactory delegate for MediatR-compatible service resolution
                ServiceRegistrationHelper.TryAddTransient<ServiceFactory>(svc, sp => sp.GetService);
            });
        }
    }
}