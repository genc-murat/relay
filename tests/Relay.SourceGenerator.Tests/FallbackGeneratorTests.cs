using Microsoft.CodeAnalysis;
using Relay.SourceGenerator.Diagnostics;
using Relay.SourceGenerator.Generators;
using System;
using System.Collections.Generic;
using Xunit;

namespace Relay.SourceGenerator.Tests;

public class FallbackGeneratorTests
{
    [Fact]
    public void GenerateBasicAddRelay_WithDefaultOptions_GeneratesValidCode()
    {
        // Arrange
        var options = new GenerationOptions
        {
            EnableNullableContext = true,
            IncludeDocumentation = true,
            EnableDIGeneration = true
        };

        // Act
        var result = FallbackGenerator.GenerateBasicAddRelay(options);

        // Assert
        Assert.NotNull(result);
        Assert.Contains("// <auto-generated />", result);
        Assert.Contains("Generated by Relay.SourceGenerator", result);
        Assert.Contains("No handlers found", result);
        Assert.Contains("#nullable enable", result);
        Assert.Contains("GeneratedRelayExtensions", result);
        Assert.Contains("AddRelayGenerated", result);
        Assert.Contains("IServiceCollection", result);
        Assert.Contains("Microsoft.Extensions.DependencyInjection", result);
    }

    [Fact]
    public void GenerateBasicAddRelay_WithoutNullableContext_DoesNotIncludeNullableDirective()
    {
        // Arrange
        var options = new GenerationOptions
        {
            EnableNullableContext = false,
            IncludeDocumentation = true
        };

        // Act
        var result = FallbackGenerator.GenerateBasicAddRelay(options);

        // Assert
        Assert.NotNull(result);
        Assert.DoesNotContain("#nullable enable", result);
    }

    [Fact]
    public void GenerateBasicAddRelay_WithoutDocumentation_DoesNotIncludeXmlComments()
    {
        // Arrange
        var options = new GenerationOptions
        {
            EnableNullableContext = true,
            IncludeDocumentation = false
        };

        // Act
        var result = FallbackGenerator.GenerateBasicAddRelay(options);

        // Assert
        Assert.NotNull(result);
        Assert.DoesNotContain("/// <summary>", result);
    }

    [Fact]
    public void GenerateBasicAddRelay_WithCustomNamespace_UsesCustomNamespace()
    {
        // Arrange
        var options = new GenerationOptions
        {
            CustomNamespace = "MyApp.DependencyInjection"
        };

        // Act
        var result = FallbackGenerator.GenerateBasicAddRelay(options);

        // Assert
        Assert.Contains("namespace MyApp.DependencyInjection", result);
    }

    [Fact]
    public void GenerateBasicAddRelay_RegistersCoreRelayServices()
    {
        // Arrange
        var options = new GenerationOptions();

        // Act
        var result = FallbackGenerator.GenerateBasicAddRelay(options);

        // Assert
        Assert.Contains("services.TryAddTransient(typeof(Relay.Core.Contracts.Core.IRelay)", result);
        Assert.Contains("services.TryAddTransient(typeof(Relay.Core.Contracts.Dispatchers.IRequestDispatcher)", result);
        Assert.Contains("services.TryAddTransient(typeof(Relay.Core.Contracts.Dispatchers.IStreamDispatcher)", result);
        Assert.Contains("services.TryAddTransient(typeof(Relay.Core.Contracts.Dispatchers.INotificationDispatcher)", result);
        Assert.Contains("FallbackRequestDispatcher", result);
    }

    [Fact]
    public void GenerateFallbackDispatcher_WithErrorMessage_IncludesErrorInComment()
    {
        // Arrange
        var options = new GenerationOptions
        {
            EnableNullableContext = true,
            IncludeDocumentation = true
        };
        var errorMessage = "Test error occurred";

        // Act
        var result = FallbackGenerator.GenerateFallbackDispatcher(options, errorMessage);

        // Assert
        Assert.NotNull(result);
        Assert.Contains("// <auto-generated />", result);
        Assert.Contains("Generated by Relay.SourceGenerator - Fallback Dispatcher", result);
        Assert.Contains($"// Reason: {errorMessage}", result);
        Assert.Contains("Using reflection-based fallback dispatcher", result);
    }

    [Fact]
    public void GenerateFallbackDispatcher_InheritsFromFallbackRequestDispatcher()
    {
        // Arrange
        var options = new GenerationOptions();
        var errorMessage = "Test error";

        // Act
        var result = FallbackGenerator.GenerateFallbackDispatcher(options, errorMessage);

        // Assert
        Assert.Contains("GeneratedRequestDispatcher : Relay.Core.Implementation.Fallback.FallbackRequestDispatcher", result);
        Assert.Contains("public GeneratedRequestDispatcher(IServiceProvider serviceProvider)", result);
        Assert.Contains(": base(serviceProvider)", result);
    }

    [Fact]
    public void GenerateFallbackDispatcher_WithCustomNamespace_UsesCustomNamespace()
    {
        // Arrange
        var options = new GenerationOptions
        {
            CustomNamespace = "MyApp.Generated"
        };

        // Act
        var result = FallbackGenerator.GenerateFallbackDispatcher(options, "error");

        // Assert
        Assert.Contains("namespace MyApp.Generated", result);
    }

    [Fact]
    public void GenerateMinimalHandlerRegistry_GeneratesEmptyRegistries()
    {
        // Arrange
        var options = new GenerationOptions
        {
            EnableNullableContext = true,
            IncludeDocumentation = true
        };

        // Act
        var result = FallbackGenerator.GenerateMinimalHandlerRegistry(options);

        // Assert
        Assert.NotNull(result);
        Assert.Contains("// <auto-generated />", result);
        Assert.Contains("Generated by Relay.SourceGenerator - Minimal Handler Registry", result);
        Assert.Contains("Fallback implementation with no registered handlers", result);
        Assert.Contains("public static class HandlerRegistry", result);
        Assert.Contains("IReadOnlyDictionary<Type, Type> RequestHandlers", result);
        Assert.Contains("new Dictionary<Type, Type>()", result);
        Assert.Contains("IReadOnlyDictionary<Type, List<Type>> NotificationHandlers", result);
        Assert.Contains("IReadOnlyDictionary<Type, Type> StreamHandlers", result);
    }

    [Fact]
    public void ShouldUseFallback_WithRecoverableException_ReturnsTrue()
    {
        // Arrange
        var exceptions = new Exception[]
        {
            new InvalidOperationException("test"),
            new ArgumentException("test"),
            new NullReferenceException("test"),
            new FormatException("test")
        };

        foreach (var exception in exceptions)
        {
            // Act
            var result = FallbackGenerator.ShouldUseFallback(exception);

            // Assert
            Assert.True(result, $"Expected {exception.GetType().Name} to allow fallback");
        }
    }

    [Fact]
    public void ShouldUseFallback_WithCriticalException_ReturnsFalse()
    {
        // Arrange
        var exceptions = new Exception[]
        {
            new OperationCanceledException("test"),
            new OutOfMemoryException("test"),
            new StackOverflowException("test")
        };

        foreach (var exception in exceptions)
        {
            // Act
            var result = FallbackGenerator.ShouldUseFallback(exception);

            // Assert
            Assert.False(result, $"Expected {exception.GetType().Name} to not allow fallback");
        }
    }

    [Fact]
    public void ReportFallbackUsage_ReportsInfoDiagnostic()
    {
        // Arrange
        var reporter = new TestDiagnosticReporter();
        var reason = "Test fallback reason";

        // Act
        FallbackGenerator.ReportFallbackUsage(reporter, reason);

        // Assert
        Assert.Single(reporter.Diagnostics);
        var diagnostic = reporter.Diagnostics[0];
        Assert.Equal(DiagnosticSeverity.Info, diagnostic.Severity);
        Assert.Contains(reason, diagnostic.GetMessage());
    }

    [Fact]
    public void GenerateCompleteFallback_GeneratesAllRequiredFiles()
    {
        // Arrange
        var options = new GenerationOptions
        {
            EnableNullableContext = true,
            IncludeDocumentation = true,
            EnableOptimizedDispatcher = false
        };
        var reporter = new TestDiagnosticReporter();

        // Act
        var result = FallbackGenerator.GenerateCompleteFallback(options, reporter);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(2, result.Count);
        Assert.True(result.ContainsKey("RelayRegistration.g.cs"));
        Assert.True(result.ContainsKey("HandlerRegistry.g.cs"));
        Assert.Single(reporter.Diagnostics); // Should report fallback usage
    }

    [Fact]
    public void GenerateCompleteFallback_WithOptimizedDispatcher_IncludesDispatcherFile()
    {
        // Arrange
        var options = new GenerationOptions
        {
            EnableOptimizedDispatcher = true
        };
        var reporter = new TestDiagnosticReporter();

        // Act
        var result = FallbackGenerator.GenerateCompleteFallback(options, reporter);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(3, result.Count);
        Assert.True(result.ContainsKey("RelayRegistration.g.cs"));
        Assert.True(result.ContainsKey("HandlerRegistry.g.cs"));
        Assert.True(result.ContainsKey("OptimizedRequestDispatcher.g.cs"));
    }

    [Fact]
    public void GenerateCompleteFallback_GeneratesValidSourceCode()
    {
        // Arrange
        var options = new GenerationOptions();
        var reporter = new TestDiagnosticReporter();

        // Act
        var result = FallbackGenerator.GenerateCompleteFallback(options, reporter);

        // Assert
        foreach (var kvp in result)
        {
            Assert.NotEmpty(kvp.Value);
            Assert.Contains("// <auto-generated />", kvp.Value);
        }
    }

    [Fact]
    public void ValidateFallbackOptions_WithValidOptions_ReturnsTrue()
    {
        // Arrange
        var options = new GenerationOptions();

        // Act
        var result = FallbackGenerator.ValidateFallbackOptions(options);

        // Assert
        Assert.True(result);
    }

    [Fact]
    public void ValidateFallbackOptions_WithNullOptions_ReturnsFalse()
    {
        // Act
        var result = FallbackGenerator.ValidateFallbackOptions(null);

        // Assert
        Assert.False(result);
    }

    // Helper class for testing diagnostic reporting
    private class TestDiagnosticReporter : IDiagnosticReporter
    {
        public List<Diagnostic> Diagnostics { get; } = new();

        public void ReportDiagnostic(Diagnostic diagnostic)
        {
            Diagnostics.Add(diagnostic);
        }
    }
}
