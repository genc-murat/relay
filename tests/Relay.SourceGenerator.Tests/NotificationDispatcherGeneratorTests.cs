using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;
using FluentAssertions;
using System.Linq;
using System.Collections.Generic;
using System.Threading;

namespace Relay.SourceGenerator.Tests;

public class NotificationDispatcherGeneratorTests
{
    [Fact]
    public void NotificationDispatcherGenerator_ShouldThrowWhenContextIsNull()
    {
        // Act
        var act = () => new NotificationDispatcherGenerator(null!);

        // Assert
        act.Should().Throw<System.ArgumentNullException>()
            .WithParameterName("context");
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldReturnEmptyString_WhenNoNotificationHandlersFound()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        result.Should().BeEmpty();
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldGenerateDispatcherClass_WhenNotificationHandlersExist()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core;

namespace TestApp
{
    public class TestNotification : INotification { }

    public class NotificationHandler
    {
        [Notification]
        public async Task HandleAsync(TestNotification notification, CancellationToken cancellationToken)
        {
            await Task.CompletedTask;
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);

        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        result.Should().NotBeEmpty();
        result.Should().Contain("class GeneratedNotificationDispatcher");
        result.Should().Contain("BaseNotificationDispatcher");
        result.Should().Contain("public override async ValueTask DispatchAsync");
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldIncludeGenerationTimestamp()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        result.Should().Contain("// <auto-generated />");
        result.Should().Contain("// Generated by Relay.SourceGenerator");
        result.Should().Contain("// Generation time:");
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldGenerateRequiredUsings()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        result.Should().Contain("using System;");
        result.Should().Contain("using System.Collections.Generic;");
        result.Should().Contain("using System.Threading;");
        result.Should().Contain("using System.Threading.Tasks;");
        result.Should().Contain("using Microsoft.Extensions.DependencyInjection;");
        result.Should().Contain("using Microsoft.Extensions.Logging;");
        result.Should().Contain("using Relay.Core;");
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldGenerateConstructor()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        result.Should().Contain("public GeneratedNotificationDispatcher(IServiceProvider serviceProvider)");
        result.Should().Contain(": base(serviceProvider)");
        result.Should().Contain("_logger = serviceProvider.GetService<ILogger<GeneratedNotificationDispatcher>>");
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldGenerateTypeSpecificDispatchMethod()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        result.Should().Contain("private async ValueTask DispatchAsync");
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldHandleMultipleNotificationTypes()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core;

namespace TestApp
{
    public class TestNotification1 : INotification { }
    public class TestNotification2 : INotification { }

    public class NotificationHandler
    {
        [Notification]
        public async Task HandleAsync(TestNotification1 notification, CancellationToken cancellationToken)
        {
            await Task.CompletedTask;
        }

        [Notification]
        public async Task HandleAsync(TestNotification2 notification, CancellationToken cancellationToken)
        {
            await Task.CompletedTask;
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithMultipleNotificationHandlers(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        result.Should().Contain("if (notificationType == typeof(");
        result.Should().Contain("else if (notificationType == typeof(");
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldGenerateExceptionHandling()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        result.Should().Contain("try");
        result.Should().Contain("catch (Exception ex)");
        result.Should().Contain("_logger?.LogError");
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldHandleStaticHandlers()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core;

namespace TestApp
{
    public class TestNotification : INotification { }

    public static class NotificationHandler
    {
        [Notification]
        public static async Task HandleAsync(TestNotification notification, CancellationToken cancellationToken)
        {
            await Task.CompletedTask;
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithStaticNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        result.Should().NotContain("GetRequiredService");
        result.Should().NotContain("using var scope");
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldHandleInstanceHandlers()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        result.Should().Contain("using var scope = CreateScope();");
        result.Should().Contain("GetRequiredService");
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldGenerateLoggingStatements()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        result.Should().Contain("_logger?.LogDebug");
        result.Should().Contain("Dispatching notification");
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldValidateNotificationParameter()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        result.Should().Contain("ValidateRequest(notification, nameof(notification))");
    }

    private Compilation CreateTestCompilation(string? additionalSource = null)
    {
        var relayCoreStubs = @"
using System;
namespace Relay.Core
{
    public interface INotification { }

    [AttributeUsage(AttributeTargets.Method)]
    public sealed class NotificationAttribute : Attribute
    {
        public int Priority { get; set; }
        public int DispatchMode { get; set; }
    }

    public abstract class BaseNotificationDispatcher
    {
        protected BaseNotificationDispatcher(IServiceProvider serviceProvider) { }
        public abstract System.Threading.Tasks.ValueTask DispatchAsync<TNotification>(TNotification notification, System.Threading.CancellationToken cancellationToken);
        protected void ValidateRequest<T>(T request, string paramName) { }
        protected System.IDisposable CreateScope() => null!;
    }
}";

        var sources = new List<string> { relayCoreStubs };
        if (additionalSource != null)
        {
            sources.Add(additionalSource);
        }

        var syntaxTrees = sources.Select(s => CSharpSyntaxTree.ParseText(s)).ToArray();

        return CSharpCompilation.Create(
            assemblyName: "TestAssembly",
            syntaxTrees: syntaxTrees,
            references: new[]
            {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Threading.Tasks.Task).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Threading.CancellationToken).Assembly.Location),
            },
            options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
    }

    private HandlerDiscoveryResult CreateDiscoveryResultWithNotificationHandler(Compilation compilation)
    {
        var notificationType = compilation.GetTypeByMetadataName("Relay.Core.INotification");
        var testNotificationType = compilation.GetTypeByMetadataName("TestApp.TestNotification") ?? notificationType;
        var handlerType = compilation.GetTypeByMetadataName("TestApp.NotificationHandler");

        var method = handlerType?.GetMembers().OfType<IMethodSymbol>().FirstOrDefault();

        if (method == null)
        {
            // Create a mock handler for testing
            var mockHandlerInfo = CreateMockNotificationHandlerInfo(compilation);
            var result = new HandlerDiscoveryResult();
            result.Handlers.Add(mockHandlerInfo);
            return result;
        }

        var handlerInfo = new HandlerInfo
        {
            MethodSymbol = method,
            Attributes = new List<RelayAttributeInfo>
            {
                new RelayAttributeInfo
                {
                    Type = RelayAttributeType.Notification,
                    AttributeData = method.GetAttributes().FirstOrDefault()
                }
            }
        };

        var discoveryResult = new HandlerDiscoveryResult();
        discoveryResult.Handlers.Add(handlerInfo);
        return discoveryResult;
    }

    private HandlerInfo CreateMockNotificationHandlerInfo(Compilation compilation)
    {
        // Create a simple notification handler source to get a real method symbol
        var mockHandlerSource = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core;

namespace MockTest
{
    public class MockNotification : INotification { }

    public class MockHandler
    {
        public async Task HandleAsync(MockNotification notification, CancellationToken cancellationToken)
        {
            await Task.CompletedTask;
        }
    }
}";

        var mockCompilation = CreateTestCompilation(mockHandlerSource);
        var mockHandlerType = mockCompilation.GetTypeByMetadataName("MockTest.MockHandler");
        var mockMethod = mockHandlerType?.GetMembers().OfType<IMethodSymbol>().FirstOrDefault();

        return new HandlerInfo
        {
            MethodSymbol = mockMethod!,
            Attributes = new List<RelayAttributeInfo>
            {
                new RelayAttributeInfo
                {
                    Type = RelayAttributeType.Notification
                }
            }
        };
    }

    private HandlerDiscoveryResult CreateDiscoveryResultWithMultipleNotificationHandlers(Compilation compilation)
    {
        var result = new HandlerDiscoveryResult();

        var handlerType = compilation.GetTypeByMetadataName("TestApp.NotificationHandler");
        var methods = handlerType?.GetMembers().OfType<IMethodSymbol>().Where(m => m.Name == "HandleAsync").ToList();

        if (methods != null && methods.Any())
        {
            foreach (var method in methods)
            {
                result.Handlers.Add(new HandlerInfo
                {
                    MethodSymbol = method,
                    Attributes = new List<RelayAttributeInfo>
                    {
                        new RelayAttributeInfo
                        {
                            Type = RelayAttributeType.Notification
                        }
                    }
                });
            }
        }

        return result;
    }

    private HandlerDiscoveryResult CreateDiscoveryResultWithStaticNotificationHandler(Compilation compilation)
    {
        var result = new HandlerDiscoveryResult();
        var handlerType = compilation.GetTypeByMetadataName("TestApp.NotificationHandler");
        var method = handlerType?.GetMembers().OfType<IMethodSymbol>().FirstOrDefault();

        if (method == null)
        {
            return result;
        }

        result.Handlers.Add(new HandlerInfo
        {
            MethodSymbol = method,
            Attributes = new List<RelayAttributeInfo>
            {
                new RelayAttributeInfo
                {
                    Type = RelayAttributeType.Notification
                }
            }
        });

        return result;
    }
}
