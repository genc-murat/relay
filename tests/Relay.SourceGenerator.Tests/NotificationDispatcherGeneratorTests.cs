using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;
using System.Linq;
using System.Collections.Generic;
using System.Threading;

namespace Relay.SourceGenerator.Tests;

public class NotificationDispatcherGeneratorTests
{
    [Fact]
    public void NotificationDispatcherGenerator_ShouldThrowWhenContextIsNull()
    {
        // Act & Assert
        var exception = Assert.Throws<System.ArgumentNullException>(() => new NotificationDispatcherGenerator(null!));
        Assert.Equal("context", exception.ParamName);
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldReturnEmptyString_WhenNoNotificationHandlersFound()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        Assert.Empty(result);
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldGenerateDispatcherClass_WhenNotificationHandlersExist()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core;

namespace TestApp
{
    public class TestNotification : INotification { }

    public class NotificationHandler
    {
        [Notification]
        public async Task HandleAsync(TestNotification notification, CancellationToken cancellationToken)
        {
            await Task.CompletedTask;
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);

        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        Assert.NotEmpty(result);
        Assert.Contains("class GeneratedNotificationDispatcher", result);
        Assert.Contains("BaseNotificationDispatcher", result);
        Assert.Contains("public override async ValueTask DispatchAsync", result);
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldIncludeGenerationTimestamp()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        Assert.Contains("// <auto-generated />", result);
        Assert.Contains("// Generated by Relay.SourceGenerator", result);
        Assert.Contains("// Generation time:", result);
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldGenerateRequiredUsings()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        Assert.Contains("using System;", result);
        Assert.Contains("using System.Collections.Generic;", result);
        Assert.Contains("using System.Threading;", result);
        Assert.Contains("using System.Threading.Tasks;", result);
        Assert.Contains("using Microsoft.Extensions.DependencyInjection;", result);
        Assert.Contains("using Microsoft.Extensions.Logging;", result);
        Assert.Contains("using Relay.Core;", result);
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldGenerateConstructor()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        Assert.Contains("public GeneratedNotificationDispatcher(IServiceProvider serviceProvider)", result);
        Assert.Contains(": base(serviceProvider)", result);
        Assert.Contains("_logger = serviceProvider.GetService<ILogger<GeneratedNotificationDispatcher>>", result);
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldGenerateTypeSpecificDispatchMethod()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        Assert.Contains("private async ValueTask DispatchAsync", result);
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldHandleMultipleNotificationTypes()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core;

namespace TestApp
{
    public class TestNotification1 : INotification { }
    public class TestNotification2 : INotification { }

    public class NotificationHandler
    {
        [Notification]
        public async Task HandleAsync(TestNotification1 notification, CancellationToken cancellationToken)
        {
            await Task.CompletedTask;
        }

        [Notification]
        public async Task HandleAsync(TestNotification2 notification, CancellationToken cancellationToken)
        {
            await Task.CompletedTask;
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithMultipleNotificationHandlers(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        Assert.Contains("if (notificationType == typeof(", result);
        Assert.Contains("else if (notificationType == typeof(", result);
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldGenerateExceptionHandling()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        Assert.Contains("try", result);
        Assert.Contains("catch (Exception ex)", result);
        Assert.Contains("_logger?.LogError", result);
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldHandleStaticHandlers()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core;

namespace TestApp
{
    public class TestNotification : INotification { }

    public static class NotificationHandler
    {
        [Notification]
        public static async Task HandleAsync(TestNotification notification, CancellationToken cancellationToken)
        {
            await Task.CompletedTask;
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithStaticNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        Assert.DoesNotContain("GetRequiredService", result);
        Assert.DoesNotContain("using var scope", result);
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldHandleInstanceHandlers()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        Assert.Contains("using var scope = CreateScope();", result);
        Assert.Contains("GetRequiredService", result);
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldHandleNonAsyncHandlers()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNonAsyncNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        Assert.Contains("handler.HandleAsync(notification, cancellationToken);", result);
        Assert.DoesNotContain("await handler.HandleAsync(notification, cancellationToken);", result);
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldOrderHandlersByPriority()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core;

namespace TestApp
{
    public class TestNotification : INotification { }

    public class HighPriorityHandler
    {
        [Notification(Priority = 10)]
        public async Task HandleAsync(TestNotification notification, CancellationToken cancellationToken)
        {
            await Task.CompletedTask;
        }
    }

    public class LowPriorityHandler
    {
        [Notification(Priority = 1)]
        public async Task HandleAsync(TestNotification notification, CancellationToken cancellationToken)
        {
            await Task.CompletedTask;
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithPriorityHandlers(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        // High priority handler should appear before low priority handler
        var highPriorityIndex = result.IndexOf("HighPriorityHandler");
        var lowPriorityIndex = result.IndexOf("LowPriorityHandler");
        Assert.True(highPriorityIndex < lowPriorityIndex, "High priority handler should be executed before low priority handler");
    }







    [Fact]
    public void GenerateNotificationDispatcher_ShouldGenerateLoggingStatements()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        Assert.Contains("_logger?.LogDebug", result);
        Assert.Contains("Dispatching notification", result);
    }

    [Fact]
    public void GenerateNotificationDispatcher_ShouldValidateNotificationParameter()
    {
        // Arrange
        var compilation = CreateTestCompilation();
        var context = new RelayCompilationContext(compilation, CancellationToken.None);
        var generator = new NotificationDispatcherGenerator(context);
        var discoveryResult = CreateDiscoveryResultWithNotificationHandler(compilation);

        // Act
        var result = generator.GenerateNotificationDispatcher(discoveryResult);

        // Assert
        Assert.Contains("ValidateRequest(notification, nameof(notification))", result);
    }

    private Compilation CreateTestCompilation(string? additionalSource = null)
    {
        var relayCoreStubs = @"
using System;
namespace Relay.Core
{
    public interface INotification { }

    public enum NotificationDispatchMode
    {
        Parallel,
        Sequential
    }

    [AttributeUsage(AttributeTargets.Method)]
    public sealed class NotificationAttribute : Attribute
    {
        public int Priority { get; set; }
        public NotificationDispatchMode DispatchMode { get; set; }
    }

    public abstract class BaseNotificationDispatcher
    {
        protected BaseNotificationDispatcher(IServiceProvider serviceProvider) { }
        public abstract System.Threading.Tasks.ValueTask DispatchAsync<TNotification>(TNotification notification, System.Threading.CancellationToken cancellationToken);
        protected void ValidateRequest<T>(T request, string paramName) { }
        protected System.IDisposable CreateScope() => null!;
    }
}";

        var sources = new List<string> { relayCoreStubs };
        if (additionalSource != null)
        {
            sources.Add(additionalSource);
        }

        var syntaxTrees = sources.Select(s => CSharpSyntaxTree.ParseText(s)).ToArray();

        return CSharpCompilation.Create(
            assemblyName: "TestAssembly",
            syntaxTrees: syntaxTrees,
            references: new[]
            {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Threading.Tasks.Task).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Threading.CancellationToken).Assembly.Location),
            },
            options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
    }

    private HandlerDiscoveryResult CreateDiscoveryResultWithNotificationHandler(Compilation compilation)
    {
        var notificationType = compilation.GetTypeByMetadataName("Relay.Core.INotification");
        var testNotificationType = compilation.GetTypeByMetadataName("TestApp.TestNotification") ?? notificationType;
        var handlerType = compilation.GetTypeByMetadataName("TestApp.NotificationHandler");

        var method = handlerType?.GetMembers().OfType<IMethodSymbol>().FirstOrDefault();

        if (method == null)
        {
            // Create a mock handler for testing
            var mockHandlerInfo = CreateMockNotificationHandlerInfo(compilation);
            var result = new HandlerDiscoveryResult();
            result.Handlers.Add(mockHandlerInfo);
            return result;
        }

        var handlerInfo = new HandlerInfo
        {
            MethodSymbol = method,
            Attributes = new List<RelayAttributeInfo>
            {
                new RelayAttributeInfo
                {
                    Type = RelayAttributeType.Notification,
                    AttributeData = method.GetAttributes().FirstOrDefault()
                }
            }
        };

        var discoveryResult = new HandlerDiscoveryResult();
        discoveryResult.Handlers.Add(handlerInfo);
        return discoveryResult;
    }

    private HandlerInfo CreateMockNotificationHandlerInfo(Compilation compilation)
    {
        // Create a simple notification handler source to get a real method symbol
        var mockHandlerSource = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core;

namespace MockTest
{
    public class MockNotification : INotification { }

    public class MockHandler
    {
        public async Task HandleAsync(MockNotification notification, CancellationToken cancellationToken)
        {
            await Task.CompletedTask;
        }
    }
}";

        var mockCompilation = CreateTestCompilation(mockHandlerSource);
        var mockHandlerType = mockCompilation.GetTypeByMetadataName("MockTest.MockHandler");
        var mockMethod = mockHandlerType?.GetMembers().OfType<IMethodSymbol>().FirstOrDefault();

        return new HandlerInfo
        {
            MethodSymbol = mockMethod!,
            Attributes = new List<RelayAttributeInfo>
            {
                new RelayAttributeInfo
                {
                    Type = RelayAttributeType.Notification
                }
            }
        };
    }

    private HandlerDiscoveryResult CreateDiscoveryResultWithMultipleNotificationHandlers(Compilation compilation)
    {
        var result = new HandlerDiscoveryResult();

        var handlerType = compilation.GetTypeByMetadataName("TestApp.NotificationHandler");
        var methods = handlerType?.GetMembers().OfType<IMethodSymbol>().Where(m => m.Name == "HandleAsync").ToList();

        if (methods != null && methods.Any())
        {
            foreach (var method in methods)
            {
                result.Handlers.Add(new HandlerInfo
                {
                    MethodSymbol = method,
                    Attributes = new List<RelayAttributeInfo>
                    {
                        new RelayAttributeInfo
                        {
                            Type = RelayAttributeType.Notification
                        }
                    }
                });
            }
        }

        return result;
    }

    private HandlerDiscoveryResult CreateDiscoveryResultWithStaticNotificationHandler(Compilation compilation)
    {
        var result = new HandlerDiscoveryResult();
        var handlerType = compilation.GetTypeByMetadataName("TestApp.NotificationHandler");
        var method = handlerType?.GetMembers().OfType<IMethodSymbol>().FirstOrDefault();

        if (method == null)
        {
            return result;
        }

        result.Handlers.Add(new HandlerInfo
        {
            MethodSymbol = method,
            Attributes = new List<RelayAttributeInfo>
            {
                new RelayAttributeInfo
                {
                    Type = RelayAttributeType.Notification
                }
            }
        });

        return result;
    }

    private HandlerDiscoveryResult CreateDiscoveryResultWithNonAsyncNotificationHandler(Compilation compilation)
    {
        // Create a simple non-async notification handler source to get a real method symbol
        var mockHandlerSource = @"
using System.Threading;
using Relay.Core;

namespace MockTest
{
    public class MockNotification : INotification { }

    public class MockHandler
    {
        public void HandleAsync(MockNotification notification, CancellationToken cancellationToken)
        {
            // Non-async handler
        }
    }
}";

        var mockCompilation = CreateTestCompilation(mockHandlerSource);
        var mockHandlerType = mockCompilation.GetTypeByMetadataName("MockTest.MockHandler");
        var mockMethod = mockHandlerType?.GetMembers().OfType<IMethodSymbol>().FirstOrDefault();

        var result = new HandlerDiscoveryResult();
        result.Handlers.Add(new HandlerInfo
        {
            MethodSymbol = mockMethod!,
            Attributes = new List<RelayAttributeInfo>
            {
                new RelayAttributeInfo
                {
                    Type = RelayAttributeType.Notification
                }
            }
        });
        return result;
    }

    private HandlerDiscoveryResult CreateDiscoveryResultWithPriorityHandlers(Compilation compilation)
    {
        var result = new HandlerDiscoveryResult();

        // Add high priority handler
        var highPriorityType = compilation.GetTypeByMetadataName("TestApp.HighPriorityHandler");
        var highPriorityMethod = highPriorityType?.GetMembers().OfType<IMethodSymbol>().FirstOrDefault();
        if (highPriorityMethod != null)
        {
            result.Handlers.Add(new HandlerInfo
            {
                MethodSymbol = highPriorityMethod,
                Attributes = new List<RelayAttributeInfo>
                {
                    new RelayAttributeInfo
                    {
                        Type = RelayAttributeType.Notification,
                        AttributeData = highPriorityMethod.GetAttributes().FirstOrDefault()
                    }
                }
            });
        }

        // Add low priority handler
        var lowPriorityType = compilation.GetTypeByMetadataName("TestApp.LowPriorityHandler");
        var lowPriorityMethod = lowPriorityType?.GetMembers().OfType<IMethodSymbol>().FirstOrDefault();
        if (lowPriorityMethod != null)
        {
            result.Handlers.Add(new HandlerInfo
            {
                MethodSymbol = lowPriorityMethod,
                Attributes = new List<RelayAttributeInfo>
                {
                    new RelayAttributeInfo
                    {
                        Type = RelayAttributeType.Notification,
                        AttributeData = lowPriorityMethod.GetAttributes().FirstOrDefault()
                    }
                }
            });
        }

        return result;
    }


}
