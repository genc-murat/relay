using FluentAssertions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

namespace Relay.SourceGenerator.Tests;

public class OptimizedDispatcherGeneratorTests
{
    private RelayCompilationContext CreateTestContext()
    {
        var code = @"
namespace Test
{
    public class TestRequest : Relay.Core.IRequest<string> { }
    public class TestHandler
    {
        [Relay.Core.Attributes.Handle]
        public async System.Threading.Tasks.ValueTask<string> HandleAsync(TestRequest request, System.Threading.CancellationToken cancellationToken)
        {
            return ""test"";
        }
    }
}";

        var compilation = CreateCompilation(code);
        return new RelayCompilationContext(compilation, System.Threading.CancellationToken.None);
    }

    private Compilation CreateCompilation(string source)
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(source);
        var references = AppDomain.CurrentDomain.GetAssemblies()
            .Where(a => !a.IsDynamic && !string.IsNullOrWhiteSpace(a.Location))
            .Select(a => MetadataReference.CreateFromFile(a.Location))
            .ToList();

        return CSharpCompilation.Create(
            "TestAssembly",
            new[] { syntaxTree },
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
    }

    [Fact]
    public void Constructor_ShouldThrowOnNullContext()
    {
        // Act
        Action act = () => new OptimizedDispatcherGenerator(null!);

        // Assert
        act.Should().Throw<ArgumentNullException>().WithParameterName("context");
    }

    [Fact]
    public void Constructor_ShouldInitializeWithContext()
    {
        // Arrange
        var context = CreateTestContext();

        // Act
        var generator = new OptimizedDispatcherGenerator(context);

        // Assert
        generator.Should().NotBeNull();
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldGenerateHeaderComments()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert
        source.Should().Contain("// <auto-generated />");
        source.Should().Contain("// Generated by Relay.SourceGenerator - Optimized Dispatcher");
        source.Should().Contain("// Generation time:");
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldIncludeRequiredUsings()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert
        source.Should().Contain("using System;");
        source.Should().Contain("using System.Collections.Generic;");
        source.Should().Contain("using System.Runtime.CompilerServices;");
        source.Should().Contain("using System.Threading;");
        source.Should().Contain("using System.Threading.Tasks;");
        source.Should().Contain("using Microsoft.Extensions.DependencyInjection;");
        source.Should().Contain("using Relay.Core;");
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldGenerateOptimizedDispatcherClass()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert
        source.Should().Contain("namespace Relay.Generated");
        source.Should().Contain("public static class OptimizedDispatcher");
        source.Should().Contain("High-performance dispatcher with specialized methods for each request type");
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldIncludeMethodImplAttribute()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert
        source.Should().Contain("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
    }

    [Fact]
    public void GenerateOptimizedDispatcher_WithEmptyHandlers_ShouldGenerateValidCode()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert
        source.Should().NotBeNullOrWhiteSpace();
        source.Should().Contain("public static class OptimizedDispatcher");
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldGenerateBasicStructure()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);
        var syntaxTree = CSharpSyntaxTree.ParseText(source);

        // Assert - With empty handlers, the generated code structure should still be syntactically correct
        // (though it may not compile due to missing references)
        syntaxTree.Should().NotBeNull();
        source.Should().Contain("public static class OptimizedDispatcher");
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldIncludeNamespace()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert
        source.Should().Contain("namespace Relay.Generated");
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldHaveProperIndentation()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert
        source.Should().Contain("    public static class OptimizedDispatcher");
        source.Should().NotContain("\t"); // Should use spaces, not tabs
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldIncludeXmlDocumentation()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert
        source.Should().Contain("/// <summary>");
        source.Should().Contain("/// </summary>");
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldGenerateUTCTimestamp()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();
        var beforeGeneration = DateTime.UtcNow;

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert
        source.Should().MatchRegex(@"// Generation time: \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} UTC");
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldHandleMultipleGenerationCalls()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source1 = generator.GenerateOptimizedDispatcher(discoveryResult);
        var source2 = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert - Both should be valid (timestamps may differ)
        source1.Should().NotBeNullOrWhiteSpace();
        source2.Should().NotBeNullOrWhiteSpace();
        source1.Should().Contain("public static class OptimizedDispatcher");
        source2.Should().Contain("public static class OptimizedDispatcher");
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldUseStaticClass()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert
        source.Should().Contain("public static class OptimizedDispatcher");
        source.Should().NotContain("public class OptimizedDispatcher"); // Not non-static
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldIncludePerformanceOptimizationComments()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert
        source.Should().Contain("High-performance dispatcher");
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldCloseAllBraces()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert
        var openBraces = source.Count(c => c == '{');
        var closeBraces = source.Count(c => c == '}');
        openBraces.Should().Be(closeBraces, "all braces should be properly closed");
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldUseValueTask()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert
        // ValueTask is more efficient than Task for hot paths
        source.Should().Contain("ValueTask");
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldGenerateWithConsistentFormatting()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);
        var lines = source.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);

        // Assert
        source.Should().NotContain("\r\n\r\n\r\n"); // No triple newlines
        lines.Should().NotBeNull();
    }

    [Fact]
    public void GenerateOptimizedDispatcher_ShouldGenerateCleanCode()
    {
        // Arrange
        var context = CreateTestContext();
        var generator = new OptimizedDispatcherGenerator(context);
        var discoveryResult = new HandlerDiscoveryResult();

        // Act
        var source = generator.GenerateOptimizedDispatcher(discoveryResult);

        // Assert - Check for clean code generation without checking compilation
        source.Should().NotContain("TODO");
        source.Should().NotContain("HACK");
        source.Should().Contain("public static class OptimizedDispatcher");
    }
}
