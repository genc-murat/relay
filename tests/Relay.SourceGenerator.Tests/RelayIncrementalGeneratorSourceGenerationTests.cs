using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Relay.SourceGenerator.Core;
using Relay.SourceGenerator.Generators;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading.Tasks;
using Xunit;

namespace Relay.SourceGenerator.Tests;

public class RelayIncrementalGeneratorSourceGenerationTests
{
    [Fact]
    public void GenerateDIRegistrationSource_WithRequestHandlers_GeneratesCorrectCode()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core.Contracts.Requests;
using Relay.Core.Contracts.Handlers;

namespace TestProject
{
    public class TestRequest : IRequest<string> { }

    public class TestHandler : IRequestHandler<TestRequest, string>
    {
        public ValueTask<string> HandleAsync(TestRequest request, CancellationToken cancellationToken)
        {
            return ValueTask.FromResult(""test"");
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var syntaxTree = compilation.SyntaxTrees.Last(); // Get the test source tree, not the stubs
        var semanticModel = compilation.GetSemanticModel(syntaxTree);
        
        var classDecl = syntaxTree
            .GetRoot()
            .DescendantNodes()
            .OfType<Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax>()
            .First(c => c.Identifier.ValueText == "TestHandler");

        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
        var classInfo = RelayIncrementalGenerator.ProcessClassSymbol(classSymbol, classDecl);

        var handlerClasses = new List<HandlerClassInfo> { classInfo };
        var options = new GenerationOptions
        {
            EnableNullableContext = true,
            IncludeDocumentation = true,
            EnableDIGeneration = true,
            EnableOptimizedDispatcher = false
        };

        // Act
        var sourceCode = typeof(RelayIncrementalGenerator)
            .GetMethod("GenerateDIRegistrationSource", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)
            .Invoke(null, new object[] { handlerClasses, options }) as string;

        // Assert
        Assert.NotNull(sourceCode);
        Assert.Contains("// <auto-generated />", sourceCode);
        Assert.Contains("#nullable enable", sourceCode);
        Assert.Contains("public static partial class RelayServiceCollectionExtensions", sourceCode);
        Assert.Contains("AddRelay", sourceCode);
        Assert.Contains("IRequestHandler", sourceCode);
        Assert.Contains("TestProject.TestHandler", sourceCode);
    }

    [Fact]
    public void GenerateDIRegistrationSource_WithNotificationHandlers_GeneratesCorrectCode()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core.Contracts.Notifications;
using Relay.Core.Contracts.Handlers;

namespace TestProject
{
    public class TestNotification : INotification { }

    public class TestHandler : INotificationHandler<TestNotification>
    {
        public ValueTask HandleAsync(TestNotification notification, CancellationToken cancellationToken)
        {
            return ValueTask.CompletedTask;
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var syntaxTree = compilation.SyntaxTrees.Last(); // Get the test source tree, not the stubs
        var semanticModel = compilation.GetSemanticModel(syntaxTree);
        
        var classDecl = syntaxTree
            .GetRoot()
            .DescendantNodes()
            .OfType<Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax>()
            .First(c => c.Identifier.ValueText == "TestHandler");

        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
        var classInfo = RelayIncrementalGenerator.ProcessClassSymbol(classSymbol, classDecl);

        var handlerClasses = new List<HandlerClassInfo> { classInfo };
        var options = new GenerationOptions
        {
            EnableNullableContext = false,
            IncludeDocumentation = false,
            EnableDIGeneration = true,
            EnableOptimizedDispatcher = false
        };

        // Act
        var sourceCode = typeof(RelayIncrementalGenerator)
            .GetMethod("GenerateDIRegistrationSource", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)
            .Invoke(null, new object[] { handlerClasses, options }) as string;

        // Assert
        Assert.NotNull(sourceCode);
        Assert.Contains("public static partial class RelayServiceCollectionExtensions", sourceCode);
        Assert.Contains("TestProject.TestHandler", sourceCode);
        Assert.DoesNotContain("#nullable enable", sourceCode); // Nullable disabled
    }

    [Fact]
    public void GenerateDIRegistrationSource_WithStreamHandlers_GeneratesCorrectCode()
    {
        // Arrange
        var source = @"
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Relay.Core.Contracts.Requests;
using Relay.Core.Contracts.Handlers;

namespace TestProject
{
    public class TestRequest : IRequest<IAsyncEnumerable<string>> { }

    public class TestHandler : IStreamHandler<TestRequest, string>
    {
        public IAsyncEnumerable<string> HandleStreamAsync(TestRequest request, CancellationToken cancellationToken)
        {
            yield break;
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var syntaxTree = compilation.SyntaxTrees.Last(); // Get the test source tree, not the stubs
        var semanticModel = compilation.GetSemanticModel(syntaxTree);
        
        var classDecl = syntaxTree
            .GetRoot()
            .DescendantNodes()
            .OfType<Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax>()
            .First(c => c.Identifier.ValueText == "TestHandler");

        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
        var classInfo = RelayIncrementalGenerator.ProcessClassSymbol(classSymbol, classDecl);

        var handlerClasses = new List<HandlerClassInfo> { classInfo };
        var options = new GenerationOptions
        {
            EnableNullableContext = true,
            IncludeDocumentation = true,
            EnableDIGeneration = true,
            EnableOptimizedDispatcher = true // Enable optimized dispatcher
        };

        // Act
        var sourceCode = typeof(RelayIncrementalGenerator)
            .GetMethod("GenerateDIRegistrationSource", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)
            .Invoke(null, new object[] { handlerClasses, options }) as string;

        // Assert
        Assert.NotNull(sourceCode);
        Assert.Contains("IStreamHandler", sourceCode);
        Assert.Contains("TestProject.TestHandler", sourceCode);
        Assert.Contains("GeneratedRequestDispatcher", sourceCode); // Optimized dispatcher enabled
    }

    [Fact]
    public void GenerateDIRegistrationSource_WithMultipleHandlers_GeneratesCorrectCode()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core.Contracts.Requests;
using Relay.Core.Contracts.Notifications;
using Relay.Core.Contracts.Handlers;

namespace TestProject
{
    public class TestRequest : IRequest<string> { }
    public class TestNotification : INotification { }

    public class RequestHandler : IRequestHandler<TestRequest, string>
    {
        public ValueTask<string> HandleAsync(TestRequest request, CancellationToken cancellationToken)
        {
            return ValueTask.FromResult(""test"");
        }
    }

    public class NotificationHandler : INotificationHandler<TestNotification>
    {
        public ValueTask HandleAsync(TestNotification notification, CancellationToken cancellationToken)
        {
            return ValueTask.CompletedTask;
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var syntaxTree = compilation.SyntaxTrees.Last(); // Get the test source tree, not the stubs
        var semanticModel = compilation.GetSemanticModel(syntaxTree);
        
        // Get both handler classes
        var classDecls = syntaxTree
            .GetRoot()
            .DescendantNodes()
            .OfType<Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax>()
            .Where(c => c.Identifier.ValueText == "RequestHandler" || c.Identifier.ValueText == "NotificationHandler")
            .ToList();

        var handlerClasses = new List<HandlerClassInfo>();
        foreach (var classDecl in classDecls)
        {
            var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
            var classInfo = RelayIncrementalGenerator.ProcessClassSymbol(classSymbol, classDecl);
            handlerClasses.Add(classInfo);
        }

        var options = new GenerationOptions
        {
            EnableNullableContext = false,
            IncludeDocumentation = false,
            EnableDIGeneration = true,
            EnableOptimizedDispatcher = false
        };

        // Act
        var sourceCode = typeof(RelayIncrementalGenerator)
            .GetMethod("GenerateDIRegistrationSource", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)
            .Invoke(null, new object[] { handlerClasses, options }) as string;

        // Assert
        Assert.NotNull(sourceCode);
        Assert.Contains("RequestHandler", sourceCode);
        Assert.Contains("NotificationHandler", sourceCode);
        Assert.Contains("IRequestHandler", sourceCode);
        Assert.Contains("INotificationHandler", sourceCode);
    }

    [Fact]
    public void GenerateDIRegistrationSource_WithExceptionForced_ThrowsException()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core.Contracts.Requests;
using Relay.Core.Contracts.Handlers;

namespace TestProject
{
    public class TestRequest : IRequest<string> { }

    public class TestHandler : IRequestHandler<TestRequest, string>
    {
        public ValueTask<string> HandleAsync(TestRequest request, CancellationToken cancellationToken)
        {
            return ValueTask.FromResult(""test"");
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var syntaxTree = compilation.SyntaxTrees.Last(); // Get the test source tree, not the stubs
        var semanticModel = compilation.GetSemanticModel(syntaxTree);
        
        var classDecl = syntaxTree
            .GetRoot()
            .DescendantNodes()
            .OfType<Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax>()
            .First(c => c.Identifier.ValueText == "TestHandler");

        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
        var classInfo = RelayIncrementalGenerator.ProcessClassSymbol(classSymbol, classDecl);

        var handlerClasses = new List<HandlerClassInfo> { classInfo };
        var options = new GenerationOptions
        {
            EnableNullableContext = true,
            IncludeDocumentation = true,
            EnableDIGeneration = true,
            EnableOptimizedDispatcher = false
        };

        // Force the exception
        RelayIncrementalGenerator.TestForceException = true;

        try
        {
            // Act & Assert
            var exception = Assert.Throws<System.Reflection.TargetInvocationException>(() =>
            {
                typeof(RelayIncrementalGenerator)
                    .GetMethod("GenerateDIRegistrationSource", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)
                    .Invoke(null, new object[] { handlerClasses, options });
            });

            Assert.IsType<InvalidOperationException>(exception.InnerException);
            Assert.Equal("Test exception", exception.InnerException.Message);
        }
        finally
        {
            // Reset the test flag
            RelayIncrementalGenerator.TestForceException = false;
        }
    }

    [Fact]
    public void GenerateOptimizedRequestDispatcher_WithRequestHandlers_GeneratesCorrectCode()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core.Contracts.Requests;
using Relay.Core.Contracts.Handlers;

namespace TestProject
{
    public class TestRequest : IRequest<string> { }

    public class TestHandler : IRequestHandler<TestRequest, string>
    {
        public ValueTask<string> HandleAsync(TestRequest request, CancellationToken cancellationToken)
        {
            return ValueTask.FromResult(""test"");
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var syntaxTree = compilation.SyntaxTrees.Last(); // Get the test source tree, not the stubs
        var semanticModel = compilation.GetSemanticModel(syntaxTree);
        
        var classDecl = syntaxTree
            .GetRoot()
            .DescendantNodes()
            .OfType<Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax>()
            .First(c => c.Identifier.ValueText == "TestHandler");

        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
        var classInfo = RelayIncrementalGenerator.ProcessClassSymbol(classSymbol, classDecl);

        var handlerClasses = new List<HandlerClassInfo> { classInfo };
        var options = new GenerationOptions
        {
            EnableNullableContext = true,
            IncludeDocumentation = true,
            EnableDIGeneration = true,
            EnableOptimizedDispatcher = true
        };

        // Act
        var sourceCode = typeof(RelayIncrementalGenerator)
            .GetMethod("GenerateOptimizedRequestDispatcher", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)
            .Invoke(null, new object[] { handlerClasses, options }) as string;

        // Assert
        Assert.NotNull(sourceCode);
        Assert.Contains("// <auto-generated />", sourceCode);
        Assert.Contains("#nullable enable", sourceCode);
        Assert.Contains("GeneratedRequestDispatcher", sourceCode);
        Assert.Contains("public class GeneratedRequestDispatcher : BaseRequestDispatcher", sourceCode);
        Assert.Contains("DispatchAsync", sourceCode);
        Assert.Contains("TestProject.TestRequest", sourceCode);
        Assert.Contains("HandlerNotFoundException", sourceCode);
    }

    [Fact]
    public void GenerateOptimizedRequestDispatcher_WithVoidRequestHandlers_GeneratesCorrectCode()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core.Contracts.Requests;
using Relay.Core.Contracts.Handlers;

namespace TestProject
{
    public class VoidRequest : IRequest { }

    public class VoidHandler : IRequestHandler<VoidRequest>
    {
        public ValueTask HandleAsync(VoidRequest request, CancellationToken cancellationToken)
        {
            return ValueTask.CompletedTask;
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var syntaxTree = compilation.SyntaxTrees.Last(); // Get the test source tree, not the stubs
        var semanticModel = compilation.GetSemanticModel(syntaxTree);
        
        var classDecl = syntaxTree
            .GetRoot()
            .DescendantNodes()
            .OfType<Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax>()
            .First(c => c.Identifier.ValueText == "VoidHandler");

        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
        var classInfo = RelayIncrementalGenerator.ProcessClassSymbol(classSymbol, classDecl);

        var handlerClasses = new List<HandlerClassInfo> { classInfo };
        var options = new GenerationOptions
        {
            EnableNullableContext = false,
            IncludeDocumentation = false,
            EnableDIGeneration = true,
            EnableOptimizedDispatcher = true
        };

        // Act
        var sourceCode = typeof(RelayIncrementalGenerator)
            .GetMethod("GenerateOptimizedRequestDispatcher", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)
            .Invoke(null, new object[] { handlerClasses, options }) as string;

        // Assert
        Assert.NotNull(sourceCode);
        Assert.Contains("GeneratedRequestDispatcher", sourceCode);
        Assert.Contains("TestProject.VoidRequest", sourceCode);
        Assert.DoesNotContain("#nullable enable", sourceCode); // Nullable disabled
    }

    [Fact]
    public void GenerateOptimizedRequestDispatcher_WithMultipleHandlerTypes_GeneratesCorrectCode()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core.Contracts.Requests;
using Relay.Core.Contracts.Handlers;

namespace TestProject
{
    public class StringRequest : IRequest<string> { }
    public class IntRequest : IRequest<int> { }
    public class VoidRequest : IRequest { }

    public class StringHandler : IRequestHandler<StringRequest, string>
    {
        public ValueTask<string> HandleAsync(StringRequest request, CancellationToken cancellationToken)
        {
            return ValueTask.FromResult(""test"");
        }
    }

    public class IntHandler : IRequestHandler<IntRequest, int>
    {
        public ValueTask<int> HandleAsync(IntRequest request, CancellationToken cancellationToken)
        {
            return ValueTask.FromResult(42);
        }
    }

    public class VoidHandler : IRequestHandler<VoidRequest>
    {
        public ValueTask HandleAsync(VoidRequest request, CancellationToken cancellationToken)
        {
            return ValueTask.CompletedTask;
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var syntaxTree = compilation.SyntaxTrees.Last(); // Get the test source tree, not the stubs
        var semanticModel = compilation.GetSemanticModel(syntaxTree);
        
        // Get all handler classes
        var classDecls = syntaxTree
            .GetRoot()
            .DescendantNodes()
            .OfType<Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax>()
            .Where(c => c.Identifier.ValueText.EndsWith("Handler"))
            .ToList();

        var handlerClasses = new List<HandlerClassInfo>();
        foreach (var classDecl in classDecls)
        {
            var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
            var classInfo = RelayIncrementalGenerator.ProcessClassSymbol(classSymbol, classDecl);
            handlerClasses.Add(classInfo);
        }

        var options = new GenerationOptions
        {
            EnableNullableContext = true,
            IncludeDocumentation = true,
            EnableDIGeneration = true,
            EnableOptimizedDispatcher = true
        };

        // Act
        var sourceCode = typeof(RelayIncrementalGenerator)
            .GetMethod("GenerateOptimizedRequestDispatcher", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)
            .Invoke(null, new object[] { handlerClasses, options }) as string;

        // Assert
        Assert.NotNull(sourceCode);
        Assert.Contains("GeneratedRequestDispatcher", sourceCode);
        Assert.Contains("TestProject.StringRequest", sourceCode);
        Assert.Contains("TestProject.IntRequest", sourceCode);
        Assert.Contains("TestProject.VoidRequest", sourceCode);
        Assert.Contains("(ValueTask<TResponse>)(object)", sourceCode); // For response handlers with type cast
    }

    [Fact]
    public void GenerateOptimizedRequestDispatcher_WithNamedHandlerMethods_GeneratesCorrectCode()
    {
        // Arrange
        var source = @"
using System.Threading;
using System.Threading.Tasks;
using Relay.Core.Contracts.Requests;
using Relay.Core.Contracts.Handlers;

namespace TestProject
{
    public class TestRequest : IRequest<string> { }

    public class TestHandler : IRequestHandler<TestRequest, string>
    {
        public ValueTask<string> HandleAsync(TestRequest request, CancellationToken cancellationToken)
        {
            return ValueTask.FromResult(""test"");
        }
    }
}";

        var compilation = CreateTestCompilation(source);
        var syntaxTree = compilation.SyntaxTrees.Last(); // Get the test source tree, not the stubs
        var semanticModel = compilation.GetSemanticModel(syntaxTree);
        
        var classDecl = syntaxTree
            .GetRoot()
            .DescendantNodes()
            .OfType<Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax>()
            .First(c => c.Identifier.ValueText == "TestHandler");

        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
        var classInfo = RelayIncrementalGenerator.ProcessClassSymbol(classSymbol, classDecl);

        var handlerClasses = new List<HandlerClassInfo> { classInfo };
        var options = new GenerationOptions
        {
            EnableNullableContext = true,
            IncludeDocumentation = true,
            EnableDIGeneration = true,
            EnableOptimizedDispatcher = true
        };

        // Act
        var sourceCode = typeof(RelayIncrementalGenerator)
            .GetMethod("GenerateOptimizedRequestDispatcher", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static)
            .Invoke(null, new object[] { handlerClasses, options }) as string;

        // Assert - Check for named handler methods
        Assert.NotNull(sourceCode);
        Assert.Contains("DispatchNamedRequestWithResponse", sourceCode);
        Assert.Contains("DispatchNamedRequestVoid", sourceCode);
        Assert.Contains("DispatchNamedHandlerWithResponse", sourceCode);
        Assert.Contains("DispatchNamedHandlerVoid", sourceCode);
        Assert.Contains("Microsoft.Extensions.DependencyInjection.IKeyedServiceProvider", sourceCode);
    }

    private static Compilation CreateTestCompilation(string source)
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(source);

        var relayCoreStubs = CSharpSyntaxTree.ParseText(@"
using System;
using System.Threading;
using System.Threading.Tasks;

namespace Relay.Core.Contracts.Requests
{
    public interface IRequest<out TResponse> { }
    public interface IRequest { }
}

namespace Relay.Core.Contracts.Notifications
{
    public interface INotification { }
}

namespace Relay.Core.Contracts.Handlers
{
    public interface IRequestHandler<in TRequest, TResponse>
    {
        ValueTask<TResponse> HandleAsync(TRequest request, CancellationToken cancellationToken);
    }

    public interface IRequestHandler<in TRequest>
    {
        ValueTask HandleAsync(TRequest request, CancellationToken cancellationToken);
    }

    public interface INotificationHandler<in TNotification>
    {
        ValueTask HandleAsync(TNotification notification, CancellationToken cancellationToken);
    }

    public interface IStreamHandler<in TRequest, TResponse>
    {
        IAsyncEnumerable<TResponse> HandleStreamAsync(TRequest request, CancellationToken cancellationToken);
    }
}

namespace Relay.Core
{
    [AttributeUsage(AttributeTargets.Method)]
    public sealed class HandleAttribute : Attribute
    {
        public string? Name { get; set; }
        public int Priority { get; set; }
    }

    [AttributeUsage(AttributeTargets.Method)]
    public sealed class NotificationAttribute : Attribute
    {
        public int Priority { get; set; }
    }

    [AttributeUsage(AttributeTargets.Method)]
    public sealed class PipelineAttribute : Attribute
    {
        public int Order { get; set; }
        public string? Scope { get; set; }
    }
}
");

        return CSharpCompilation.Create(
            assemblyName: "TestAssembly",
            syntaxTrees: new[] { relayCoreStubs, syntaxTree },
            references: new[]
            {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Threading.Tasks.Task).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Threading.CancellationToken).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Runtime.AssemblyTargetedPatchBandAttribute).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(System.Collections.Generic.IAsyncEnumerable<>).Assembly.Location)
            },
            options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
    }
}